{% extends "../demos.html" %}

{% block subSectionClasses %}demo_hello_world{% endblock %}
{% block meta_title %}Demo - Hello World!{% endblock %}
{% block meta_description %}"Hello World!" demo and tutorial using Spincast{% endblock %}

{% block subBody %}

<div class="container">

    <div id="sectionTitle" class="row"> 
        <div class="col-xs-12">
            <h2 class="shortTop">
            	<a class="anchor" href="#top" title="permanent link"></a>
                "Hello World!" tutorial
            </h2>
        </div>
    </div>
    
    <div class="row"> 
    
        {#==========================================
        Hello World (quick version)
        ==========================================#}
        <div class="col-xs-12">
            
            <p>
            	In this tutorial, we're going to present two "Hello World!" versions:
            	
            	<ul class="tutoBullets">
            		<li>
            			<strong><a href="#hello_world_quick">A quick and dirty version</a></strong>: This example will be very simple and 
            			its only purpose will be to show how a Spincast application can be quickly bootstrapped.
            		</li>
            		<li>
            			<strong><a href="#hello_world_scalable">A more scalable version</a></strong>: 
            			In that one, we will use a better structure for our application 
            			and we will introduce some core Spincast features.
            		</li>
            	</ul>
            </p>

            <h4 class="shortTop">
                <a class="anchor_small" id="hello_world_quick" href="#hello_world_quick" title="permanent link"></a>
                <em>1. A quick and dirty version</em>
            </h4>
            <p>
                <img class="inlineIcon" src="/public/images/icons/para.png" />
                First, you add the latest version of the <code>org.spincast:spincast-default</code>
                Maven artifact to your <code>pom.xml</code> (or <code>build.gradle</code>):
                <div>
                    <p>
                        <pre class="ace ace-xml"
>&lt;dependency>
    &lt;groupId>org.spincast&lt;/groupId>
    &lt;artifactId>spincast-default&lt;/artifactId>
    &lt;version>{{spincast.spincastCurrrentVersion}}&lt;/version>
&lt;/dependency></pre> 
                    </p>
                    <p>
                    </p>  
                </div>
            </p>
            <p class="subSection">
                <img class="inlineIcon" src="/public/images/icons/para.png" />
                Then you bootstrap everything using a <code>main(...)</code> method :
                <div>
                    <p>
                        <pre class="ace ace-java"
>public class App {

    public static void main(String[] args) {

        Injector guice = Guice.createInjector(new SpincastDefaultGuiceModule(args));

        DefaultRouter router = guice.getInstance(DefaultRouter.class);
        
        router.GET("/").save(context -&gt; context.response().sendPlainText("Hello World!"));

        guice.getInstance(Server.class).start();
    }
}</pre> 
                    </p>
                    <p>
                        <span class="explanation">Explanation :</span><br />
                        <em class="explTip">(Tip : try hovering/clicking the page numbers below!)</em>
                        <ul>
                            <li>
                                <span class="code-line-nbr">3</span> : A good old Java's <code>main(...)</code> method! This
                                is the entry point of a standard Spincast application.
                            </li>
                            <li>
                                <span class="code-line-nbr">5</span> : The very first thing a Spincast application
                                does is to create a Guice context. Here, we use the provided
                                <code>SpincastDefaultGuiceModule</code> module. This module binds a default
                                implementation for all the required components of a Spincast application.
                            </li>
                            <li>
                                <span class="code-line-nbr">7</span> : We get the default Router (<code>DefaultRouter</code>) from Guice.
                            </li>
                            <li>
                                <span class="code-line-nbr">9</span> : We add a <code>GET</code> Route for the 
                                <code>"/"</code> index page, using a Java 8's <code>lambdas</code> syntax. 
                                 This inline <code>route handler</code> sends a plain text "<em>Hello World!</em>" message to the user.
                            </li>
                            <li>
                                <span class="code-line-nbr">11</span> : We get the HTTP Server (<code>Server</code>) from Guice and
                                we start it!
                            </li>
                        </ul>
                    </p> 
                    <p>
                       Now, if you would point your browser to <code>http://localhost:44419</code> 
                       (Spincast default port is <code>44419</code>), you should see the
                       "<em>Hello World!</em>" message.
                    </p> 
                </div>
            </p>
            <p>
                <img class="inlineIcon" src="/public/images/icons/para.png" />
                Here's the exact same example but using Java 7, so without <code>lambdas</code>. We prefer this version
                for a first example because the types of the various components are more obvious!:
            </p>
            <p>
                <div>
                    <p>
                        <pre class="ace ace-java"
>public class App {

    public static void main(String[] args) {

        Injector guice = Guice.createInjector(new SpincastDefaultGuiceModule(args));

        DefaultRouter router = guice.getInstance(DefaultRouter.class);

        router.GET("/").save(new DefaultHandler() {
            @Override
            public void handle(DefaultRequestContext context) {
                context.response().sendPlainText("Hello World!");
            }
        });

        guice.getInstance(Server.class).start();
    }
}</pre> 
                    </p>
                    <p>
                        <span class="explanation">Explanation :</span><br />
                        <ul>
                            <li>
                                <span class="code-line-nbr">9-14</span> : We can now clearly see that the
                                <code>save(...)</code> method in fact takes a <code>Route Handler</code> as a parameter.
                                In this simple example, the <code>Route Handler</code> is declared <em>inline</em> using the 
                                <code>DefaultHandler</code> interface. We'll learn more about route handlers in the
                                next example. 
                            </li>
                        </ul>
                    </p> 
                </div>
            </p>
        </div>
        
        {#==========================================
        Hello World (more scalable version)
        ==========================================#}
        <div class="col-xs-12">

            <h4 class="shortTop">
                <a class="anchor_small" id="hello_world_scalable" href="#hello_world_scalable" title="permanent link"></a>
                <em>2. A more scalable version</em>
            </h4>
            <p>
                We're not big fans of those very short "Hello world!" examples because, in real life, you
                usually don't develop such basic applications. You want an architecture that 
                is flexible and scalable! So, let's use a more flexible structure now.
            </p>
            <p>
                In this second example we'll:
                
                <ul>
                    <li>
                        Make the <code>App</code> class itself being managed by Guice.
                    </li>
                    <li>
                        Use a <em>custom</em> Guice module.
                    </li>
                    <li>
                        Learn how to extend the <code>Request Context</code> type.
                    </li>
                </ul>
            </p>

            <p>
                <img class="inlineIcon" src="/public/images/icons/para.png" />
                If you look carefully, in the previous example we used a lot of <code><em>Default</em></code> components
                (<code>"DefaultRouter"</code> for example). 
                Those <code>Default</code> components are useful to have a quick up and running Spincast application. 
                But they hide the fact that they 
                represent objects that are actually <em>parameterized</em>. In Spincast, most of the components related to 
                the routing process are parameterized with the <code>Request Context</code> type. You can learn more about
                this topic in the <a href="/documentation#request_context"><code>The Request Context</code></a> 
                section of the documentation, but we'll introduce it briefly here.
            </p>   
            <p>
                A <code>Request Context</code> is the object Spincast passes to the matching <code>Route Handlers</code>
                when a request arrives. This object allows your handlers to access information
                about the current request (its <code>body</code>, <code>headers</code>, <code>path parameters</code>, etc.) and
                to build the response that is going to be sent back (its <code>body</code>, <code>headers</code>, <code>http status</code>, etc.).
                But there are also more generic <em>utility methods</em> on the <code>Request Context</code>, methods not directly
                related to the request or the response. Here's a quick example :
            </p>  
            <div>
                <p>
                    {% verbatim %}<pre class="ace ace-java"
>public void myHandler(DefaultRequestContext context) {

    Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();
    params.put("name", "Stromgol");
    String result = context.templating().evaluate("Hello {{name}}", params);
    
    // Do something with the result...
}</pre>{% endverbatim %}
                </p>
                    <p>
                        <span class="explanation">Explanation :</span>
                        <ul>
                            <li>
                                <span class="code-line-nbr">5</span> : The <code>templating()</code> "method"
                                is not directly related to the <em>request</em> or the <em>response</em>. 
                                It's an <code><em>add-on</em></code> that provides <em>utilities</em> to the 
                                <code>Route Handlers</code>.
                            </li>
                        </ul>
                    </p>  
            </div>
            <p>
                <img class="inlineIcon" src="/public/images/icons/para.png" />
                In our first "Hello World" example, the <code>request context</code> type was <code>DefaultRequestContext</code>, 
                which is the default.
                In Spincast, this default type <em>can be extended</em>, you can add extra
                functionalities to it! Those functionalities can be simple methods or full objects, 
                called <code>add-ons</code>. Most of the time, those <code>add-ons</code> are provided by
                <a href="/plugins"><code>plugins</code></a>.
            </p>  
            <p>
                But why would we want to extend the <code>Request Context</code> in the first place? 
            </p>  
            <p>
                Imagine a <code>plugin</code>
                which job is to manage <em>authentification</em> and <em>autorization</em>. Wouldn't it be nice if
                this plugin could add some extra functionalities to the <code>Request Context</code>? 
                For example :   
            </p>  
            <p>
                <div>
                    <p>
                        <pre class="ace ace-java" data-ace-hi="4,18,4,43|5,37,5,65"
>router.GET("/").save(new DefaultHandler() {
    @Override
    public void handle(DefaultRequestContext context) {

        if(context.auth().isAuthenticated()) {
            String username = context.auth().user().getUsername();
            // ...
        }
    }
});</pre> 
                    </p> 
                </div>
            </p>
            <p>
                This is what being able to extend the <code>Request Context</code> allows.
            </p>
            <p>
                <img class="inlineIcon" src="/public/images/icons/para.png" />
                So in this new and improved "Hello world!" example, we're going to use a <em>custom</em>
                <code>Request Context</code> type: <code>AppRequestContext</code>. We're going to add a simple method 
                to it : <code><em>translate(String sentence, Locale from, Locale to)</em></code>,
                which job will be to translate a sentence from one language to another. By adding this
                new method to our custom <code>Request Context</code> type, our <code>Route Handlers</code> will have
                easy access to it.
            </p>
            <p>
                <img class="inlineIcon" src="/public/images/icons/para.png" />
                Note that, for this second example, we still have to include the <code>org.spincast:spincast-default</code>
                Maven artifact because, even if we'll use a custom <code>Request Context</code> type,  we'll still be
                using all the other default components (the default <code>HTTP Server</code>, for example).
            </p>
            <p class="subSection">
                <img class="inlineIcon" src="/public/images/icons/para.png" />
                Let's first have a look at what our new <code>App</code> class will be. We'll create the other
                required components after.
                
                <div>
                    <p>
                        <pre class="ace ace-java"
>public class App {

    public static void main(String[] args) {

        Injector guice = Guice.createInjector(new AppModule());

        App app = guice.getInstance(App.class);
        app.start();
    }

    private final Server server;
    private final Router&lt;AppRequestContext, DefaultWebsocketContext&gt; router;

    @Inject
    public App(Server server, Router&lt;AppRequestContext, DefaultWebsocketContext&gt; router) {
        this.server = server;
        this.router = router;
    }

    public void start() {

        this.router.GET("/").save(new Handler&lt;AppRequestContext&gt;() {

            @Override
            public void handle(AppRequestContext context) {
                String translated = context.translate("Hello World!",
                                                      Locale.ENGLISH,
                                                      Locale.FRENCH);
                context.response().sendPlainText(translated);
            }
        });

        this.server.start();
    }
}</pre> 
                    </p>
                    <p>
                        <span class="explanation">Explanation :</span>
                        <ul>
                            <li>
                                <span class="code-line-nbr">1</span> : The <code>App</code> class is still the
                                entry point of our application but, in this new example, it is also going to 
                                be <em>part of the Guice context</em>!
                            </li>
                            <li>
                                <span class="code-line-nbr">5</span> : Instead of using the default 
                                <code>SpincastDefaultGuiceModule</code> Guice module provided by Spincast, we
                                use a <em>custom</em> Guice module, <code>AppModule</code> (listed below).
                            </li>
                            <li>
                                <span class="code-line-nbr">7-8</span> : When the Guice context is created, we
                                get the <code>App</code> instance and we call its <code>start()</code> method.
                                As you'll see, we'll bind the <code>App</code> class itself in our
                                custom <code>AppModule</code> module, so Guice manages it!
                            </li>
                            <li>
                                <span class="code-line-nbr">14-18</span> : Since the <code>App</code> instance is
                                managed by Guice, all the required dependencies will be automatically injected
                                in its constructor. Here, we inject the HTTP Server and
                                a <em>custom and parameterized</em> Router : 
                                <code>Router&lt;AppRequestContext, DefaultWebsocketContext&gt;</code>.
                                We'll see that because the Router is parameterized with a <em>custom</em> 
                                <code>Request Context</code> type, <code><em>"AppRequestContext"</em></code>, our <code>Route Handlers</code> will
                                have access to a new <code>translate(...)</code> method... You can see that the Router is also
                                parameterized with a <em>Websocket context</em> type, but that's not important in this example. 
                            </li>
                            <li>
                                <span class="code-line-nbr">20</span> : The <code>start()</code> method called 
                                at line <span class="code-line-nbr">8</span>, once the
                                Guice context is created.
                            </li>
                            <li>
                                <span class="code-line-nbr">22</span> : We add a <code>GET</code> Route for the <code>"/"</code> endpoint.
                                Here, we won't use Java 8 <code>lambdas</code> or <code>method handles</code> so you can clearly see
                                the types involved. Since the Router, 
                                <code><em>Router&lt;AppRequestContext, DefaultWebsocketContext&gt;</em></code>, 
                                is parameterized with our custom 
                                <code>Request Context</code> type, the handler type,
                                <code><em>Handler&lt;AppRequestContext&gt;</em></code>, will also be.
                            </li>
                            <li>
                                <span class="code-line-nbr">25</span> : The <code>handle(...)</code> method receives an
                                instance of our
                                custom <code>Request Context</code> type, <code><em>"AppRequestContext"</em></code>.
                            </li>
                            <li>
                                <span class="code-line-nbr">26-28</span> : We can now use our new 
                                <code>translate(...)</code> method, available directly on the <code>Request Context</code>
                                object!
                            </li>
                            <li>
                                <span class="code-line-nbr">33</span> : We start the Server.
                            </li>
                        </ul>
                    </p>  
                </div>
            </p>  

            <p class="subSection">
                <img class="inlineIcon" src="/public/images/icons/para.png" />
                Now that we looked at the new <code>App</code> class, let's create our custom <code>AppRequestContext</code> 
                type in which the new <code>translate(...)</code> method will be defined :
                <div>
                    <p>
                        <pre class="ace ace-java"
>public interface AppRequestContext extends RequestContext&lt;AppRequestContext&gt; {

    public String translate(String sentence, Locale from, Locale to);

    // Other custom methods and/or add-ons...
}</pre> 
                    </p>
                    <p>
                        <span class="explanation">Explanation :</span>
                        <ul>
                            <li>
                                <span class="code-line-nbr">1</span> : A custom <code>Request Context</code> interface
                                must extend the <code>RequestContext</code> base interface and parameterize it
                                using <em>its own type</em>. To learn more about this, check the 
                                <a href="/documentation#extending_request_context">Extending the Request Context</a>
                                section of the documentation.
                            </li>
                            <li>
                                <span class="code-line-nbr">3</span> : We declare our custom <code>translate(...)</code> method.
                            </li> 
                        </ul>
                    </p>  
                </div>
            </p>
             
            <p class="subSection">
                <img class="inlineIcon" src="/public/images/icons/para.png" />
                Then, let's add an implementation for this interface :
                <div>
                    <p>
                        <pre class="ace ace-java"
>public class AppRequestContextDefault extends RequestContextBase&lt;AppRequestContext&gt;
                                      implements AppRequestContext {

    @AssistedInject
    public AppRequestContextDefault(@Assisted Object exchange,
                                    RequestContextBaseDeps&lt;AppRequestContext&gt; requestContextBaseDeps) {
        super(exchange, requestContextBaseDeps);
    }

    @Override
    public String translate(String sentence, Locale from, Locale to) {

        // Ok, it's more hardcoded than translated for now!
        return "Salut, monde!";
    }
}</pre> 
                    </p>
                    <p>
                        <span class="explanation">Explanation :</span>
                        <ul>
                            <li>
                                <span class="code-line-nbr">1-2</span> : Our 
                                implementation class extends the <code>RequestContextBase</code>
                                class to keep all the functionalities of the default
                                <code>Request Context</code>, but also implements
                                our custom <code>AppRequestContext</code> interface, where our new
                                <code>translate(...)</code> method is declared.
                            </li>
                            <li>
                                <span class="code-line-nbr">4-8</span> : The constructor is annotated with
                                <code>@AssistedInject</code> because it will be used by a Guice
                                <a href="https://github.com/google/guice/wiki/AssistedInject">assisted factory</a>.
                                Don't worry too much about this or about the parameters, 
                                they are simply required by the parent class's constructor.
                            </li>
                            <li>
                                <span class="code-line-nbr">10-15</span> : A dummy implementation of our new
                                method, <code>translate(...)</code>. 
                            </li> 
                        </ul>
                    </p>  
                </div>
            </p>
            
            <p class="subSection">
                <img class="inlineIcon" src="/public/images/icons/para.png" />
                Finally, we bind everything together by creating a custom 
                Guice module,  <code>AppModule</code>. This module is the one
                used by our <code>App</code> class to create the Guice context.
                <div>
                    <p>
                        <pre class="ace ace-java"
>public class AppModule extends SpincastDefaultGuiceModule {

    @Override
    protected void configure() {
        super.configure();
        bind(App.class).in(Scopes.SINGLETON);
    }

    @Override
    protected Class&lt;? extends RequestContext&lt;?&gt;&gt; getRequestContextImplementationClass() {
        return AppRequestContextDefault.class;
    }
    
}</pre> 
                    </p>
                    <p>
                        <span class="explanation">Explanation :</span>
                        <ul>
                            <li>
                                <span class="code-line-nbr">1</span> : Our custom module extends 
                                <code>SpincastDefaultGuiceModule</code> since we want to keep the
                                default bindings and only tweak a few things.
                            </li>
                            <li>
                                <span class="code-line-nbr">6</span> : In the overidden <code>configure()</code>
                                method, we bind our <code>App</code> class itself! That way, Guice knows about it
                                and is able to inject the dependencies it requires.
                            </li>
                            <li>
                                <span class="code-line-nbr">9-12</span> : We override the 
                                <code>getRequestContextImplementationClass()</code> method to let Spincast know that
                                it has to use our custom
                                <code>AppRequestContextDefault</code> Request Context type instead of the default one!
                                Note that Spincast will automatically find the associated <code>AppRequestContext</code>
                                interface and will use it to parameterize the Router and the other routing
                                related components.    
                            </li>  
                        </ul>
                    </p>  
                </div>
            </p>
            <p class="tallTop">
                And that's it! If you start this application (using the <code>main(...)</code> method of
                the <code>App</code> class) and point your browser to
                <code>http://localhost:44419</code>, you'll see "<em>Salut, monde!</em>".
            </p>    
            <p>   
                Extending the <code>Request Context</code> type may seem like a lot of code! 
                But once in place, adding new functionalities is pretty easy. And you'll have a solid and flexible 
                base to build your application.
             </p>  
             <p>   
                That said, if it's too much, you can also start using 
                Spincast with the provided <em>default</em> components and only switch to custom ones 
                when you feel ready...
            </p>
            <p>
                Note that if you use the <a href="/documentation#quick_start">Quick Start</a>
                application as a start, the customization of
                the <code>Request Context</code> type <em>has already been done for you</em>.
            </p>

        </div>
        
        {#==========================================
        More
        ==========================================#}
        <div class="col-xs-12">
            
            <h4 class="shortTop">
                <a class="anchor_small" id="more" href="#more" title="permanent link"></a>
                More info
            </h4>

            <p>
                Our second example was a good step forward. But in a real life application, your logic
                wouldn't all be inside a single <code>App</code> class! You would have <code>controllers</code>,
                <code>services</code>, <code>respositories</code>, etc.
            </p>
            <p>
                Make sure you read the <a href="/documentation#bootstrapping">Bootstrapping your app</a> section
                of the documentation for more ideas on how to structure a real life Spincast application.
            </p>
        </div>

    </div>

   
</div>

{% endblock %}