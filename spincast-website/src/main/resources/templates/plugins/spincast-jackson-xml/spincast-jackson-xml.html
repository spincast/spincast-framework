{#==========================================
Spincast Jackson XML plugin
==========================================#}
{% extends "../../layout.html" %}

{% block sectionClasses %}plugins plugins-spincast-jackson-xml{% endblock %}
{% block meta_title %}Plugins - Spincast Jackson XML{% endblock %}
{% block meta_description %}Spincast Jackson XML plugin provides XML functionalities using Jackson.{% endblock %}

{% block scripts %}
<script>

    {#==========================================
    Initialize the Table Of Content
    ==========================================#}
    $(function() {
        app.toc(230);
    });

</script>
{% endblock %}

{% block body %}

<div class="container pluginDoc">

    <ol class="breadcrumb">
        <li><span class="glyphicon glyphicon-menu-right"> </span> <a href="/plugins">Plugins</a></li>
        <li class="active">Spincast Jackson XML plugin</li>
    </ol>
    
    <div id="sectionTitle" class="row"> 
        <div class="col-xs-12">
            <a href="#top"><h2 class="shortTop shortBottom"> Spincast Jackson XML <span>plugin</span></h2></a>
            <div class="pluginBadges">
                <div class="pluginBadgeCore hint--top-left hint--bounce" 
                     data-hint="Core plugin included in the 'spincast-default' artifact"><span class="glyphicon glyphicon-check"></span> default</div>
                <span class="clear"></span>
            </div> 
        </div>
    </div>
    
    <div id="sectionTitleFixed" class="row"> 
        <div class="col-xs-12">
            <a href="#top"><h2 class="shortTop"><img src="/public/images/logo_xsmall.png" /> Spincast Jackson XML <span>plugin</span></h2></a>
        </div>
    </div>

    <div class="row">
        <nav id="toc" class="longTitle col-md-3">
            <ul class="nav nav-stacked">
                <li class="openable"><a href="#top">Overview</a></li>
                <li class="openable"><a href="#installation">Installation</a></li>
                <li class="openable"><a href="#xmlmanager"><code>IXmlManager</code></a></li>   
                <li class="openable">
                    <a href="#config">(de)serialization configurations</a>
                    <ul class="nav nav-stacked">
                        <li><a href="#annotating_objects">Annotating the Objects</a></li>
                        <li><a href="#mixins">Using mix-ins</a></li> 
                    </ul>
                </li>  
            </ul>
        </nav>
        
        <div id="toc-content" class="col-md-9">
        
            <section id="overview">
            
                <h3 class="noTop">
                    <a class="anchor" href="#overview" title="permanent link"></a>
                    Overview
                </h3>
                <p>
                    The <code>Spincast Jackson XML</code> plugin provides XML functionalities
                     using <a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>. It contains an implementation
                    of the <a href="#xmlmanager"><code>IXmlManager</code></a> interface.
                </p>
                <p>
                    Most of the time, the <code>IXmlManager</code> interface is used directly from
                    the <code>request context</code> via the 
                    <a href="/documentation#core_rc_methods"><code>xml()</code> method</a> or indirectly via
                    some methods on the <a href="/plugins/spincast-response#request_context_addon"><code>response()</code> add-on</a>. 
                </p>
                <p>    
                    For example:
                </p>
                
                <p>
                    <div>
                        <p>
                            {% verbatim %}<pre class="ace ace-java" data-ace-hi="5,37,5,68|8,15,8,43"
>public class AppController {

    public void myHandler(IDefaultRequestContext context) {

        // Create a Json object from a XML String, using the "xml()" add-on
        IJsonObject jsonObj = context.xml().fromXml("&lt;user&gt;&lt;/user&gt;");

        // Send an object as XML, using the "response()" add-on
        context.response().sendXml(jsonObj);
    }
}</pre>{% endverbatim %}
                        </p>
                    </div>
                </p>
                <p>
                    You can also directly inject the <code>IXmlManager</code>
                    instance where you need it in your application.
                </p>
  
            </section>
            
	        <section id="installation">
                <h3>
                    <a class="anchor" href="#installation" title="permanent link"></a>
                    Installation
                </h3>
	            <p>
	                If you use the <code>spincast-default</code> artifact, this plugin is already installed so
	                you have nothing more to do!
	            </p>
	            <p>
                    <i class="subIcon glyphicon glyphicon-share-alt"></i>
	                If you start from scratch using the <code>spincast-core</code> artifact, you can use the
	                plugin by adding this artifact to your project:
	                <div>
	                    <p>
	                        <pre class="ace ace-xml"
>&lt;dependency&gt;
    &lt;groupId&gt;org.spincast&lt;/groupId&gt;
    &lt;artifactId&gt;spincast-plugins-jackson-xml&lt;/artifactId&gt;
    &lt;version&gt;{{spincastCurrrentVersion}}&lt;/version&gt;
&lt;/dependency&gt;</pre> 
	                    </p>
	                </div>  
	            </p>
	            <p>
	                <i class="subIcon glyphicon glyphicon-share-alt"></i>
	                You then install the plugin's Guice module, by passing it to the <code>Guice.createInjector(...)</code> method:
	                <div>
	                    <p>
	                        <pre class="ace ace-java" data-ace-hi="2,8,2,73"
>Injector guice = Guice.createInjector(
        new SpincastCoreGuiceModule(args),
        new SpincastJacksonXmlPluginGuiceModule(IAppRequestContext.class)
        // other modules...
        );</pre> 
	                    </p>
	                </div>   
	            </p>
	            <p>
	                ... or by using the <code>install(...)</code> method from your custom Guice module:
	                <div>
	                    <p>
	                        <pre class="ace ace-java" data-ace-hi="5,8,5,83"
>public class AppModule extends SpincastCoreGuiceModule {

    @Override
    protected void configure() {
        super.configure();
        install(new SpincastJacksonXmlPluginGuiceModule(getRequestContextType()));
        // other modules...
    }
    
    // ...
}</pre> 
	                    </p>
	                </div>   
	            </p>
            </section>
            
            <section id="xmlmanager">
                <h3 class="noTop">
                    <a class="anchor" href="#xmlmanager" title="permanent link"></a>
                    The <code>IXmlManager</code> interface
                </h3>
                <p>
                </p> 
                
                <div id="methods">
                    <p>
                        <h4><i class="subIcon glyphicon glyphicon-share-alt"></i> Methods :</h4>
                        <ul class="apiList">
   
   
   
   
<li>
    <code class="apiItem">String <span>toXml</span>(Object obj)</code>
    <div class="well">
        Converts an object to XML.
<br />If the object to convert is a <code>IJsonObject</code>, its elements
 of type "IJsonArray" will have a "isArray='true'" attribute
 added. This way, the XML can be deserialized back to a
 <code>IJsonObject</code> correctly.

    </div>
</li>

<li>
    <code class="apiItem">String <span>toXml</span>(Object obj, boolean pretty)</code>
    <div class="well">
        Converts an object to XML.

        <div class="apiItemFooter">
            @param pretty If <code>true</code>, the generated XML will
 be formatted.

        </div>
    </div>
</li>

<li>
    <code class="apiItem">IJsonObject <span>fromXml</span>(String xml)</code>
    <div class="well">
        Deserializes a XML to an <code>IJsonObject</code>. This
 will correctly manage the XML generated by
 toXml(), arrays included.

    </div>
</li>

<li>
    <code class="apiItem">IJsonArray <span>fromXmlToJsonArray</span>(String xml)</code>
    <div class="well">
        Deserializes a XML to an <code>IJsonArray</code>. This
 will correctly manage the XML generated by
 toXml(), arrays included.

    </div>
</li>

<li>
    <code class="apiItem">&lt;T&gt; T <span>fromXml</span>(String xml, Class&lt;T&gt; clazz)</code>
    <div class="well">
        Deserializes a XML to the given Class.
<br />Be aware that if you use a default Type like
<br />Map&lt;String, Object&gt;, the arrays will probably
 won't be deserialized correctly. Use the
 version returning a <code>IJsonObject</code> to get the
 arrays to work out of the box!

    </div>
</li>

<li>
    <code class="apiItem">&lt;T&gt; T <span>fromXmlToType</span>(String xml, Type type)</code>
    <div class="well">
        Deserializes a XML to the given Type.
<br />Be aware that if you use a default Type like
<br />Map&lt;String, Object&gt;, the arrays will probably
 won't be deserialized correctly. Use the
 version returning a <code>IJsonObject</code> to get the
 arrays to work out of the box!

    </div>
</li>

<li>
    <code class="apiItem">&lt;T&gt; T <span>fromXmlInputStream</span>(InputStream inputStream, Class&lt;T&gt; clazz)</code>
    <div class="well">
        Deserializes a XML inputstream to the given Type.
<br />Be aware that if you use a default Type like
<br />Map&lt;String, Object&gt;, the arrays will probably
 won't be deserialized correctly. Use the
 version returning a <code>IJsonObject</code> to get the
 arrays to work out of the box!

    </div>
</li>



                        </ul>
                    </p>
                </div>
            </section>
            
           
            <section id="config">
                <h3 class="noTop">
                    <a class="anchor" href="#config" title="permanent link"></a>
                    (de)serialization configurations
                </h3>
                <p>
                    Jackson allows some configuration when serializing and deserializing an object.
                </p> 
                <p>
                    Most of those configurations
                    are defined <a href="http://wiki.fasterxml.com/JacksonAnnotations">using annotations</a>.
                    You can annotate the objects directly, or you can use <code>mix-ins</code>.
                </p>
                
                <div id="annotating_objects">
                    <p>
                        <h4>
                            <a class="anchor_small" href="#annotating_objects" title="permanent link"></a>
                             Annotating the objects :
                        </h4>   
                    </p>
                    
                    <p>
                        If you don't minds annotating your objects with Jackson specific annotations,
                        this is maybe the simplest thing to do. For example, let's say you have a <code>User</code>
                        class that has two fields, <code>name</code> and <code>title</code>, and you don't want 
                        to keep the <code>title</code> field when you 
                        serialize an instance of this class:
                    </p> 
                    <p>
                        <div>
                            <p>
                                <pre class="ace ace-java"
>public class User implements IUser {

    private String name;
    private String title;

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String getTitle() {
        return this.title;
    }

    @Override
    public void setTitle(String title) {
        this.title = title;
    }
}</pre> 
                            </p>
                        </div>   
                    </p>
                    <p>
                        To ignore the <code>title</code> field to be included during the serialization, you can simply
                        annotate the <code>getTitle()</code> method with
                        <code>@JsonIgnore</code> (yes, you use the same annotations than the ones for <em>Json</em> mix-ins):
                        <div>
                            <p>
                                <pre class="ace ace-java" data-ace-hi="16,4,16,15"
>public class User implements IUser {

    private String name;
    private String title;

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public void setName(String name) {
        this.name = name;
    }

    @Override
    @JsonIgnore
    public String getTitle() {
        return this.title;
    }

    @Override
    public void setTitle(String title) {
        this.title = title;
    }
}</pre> 
                            </p>
                        </div>   
                    </p>
                    <p>
                    If you serialize an instance of this class using the <code>XML Manager</code>,
                    only the <code>name</code> property would be kept:
                        <div>
                            <p>
                                <pre class="ace ace-java"
>IUser user = new User();
user.setName("Stromgol");
user.setTitle("alien");

String xml = getXmlManager().toXml(user);
assertNotNull(xml);
assertEquals("&lt;User&gt;&lt;name&gt;Stromgol&lt;/name&gt;&lt;/User&gt;", xml);</pre> 
                            </p>
                        </div>   
                    </p>
   
                </div>
                
                <div id="mixins">
                    <p>
                        <h4>
                            <a class="anchor_small" href="#mixins" title="permanent link"></a>
                             Using mix-ins:
                        </h4>   
                    </p>
                    
                    <p>
                        Many developers (us included) don't like to pollute their model classes
                        with too many annotations. Lucky us, Jackson provides a way to configure
                        objects <em>from the outside</em>, without annotating the objects directly, by using what is called 
                        <a href="http://wiki.fasterxml.com/JacksonMixInAnnotations"><code>mix-ins</code> annotations</a>.
                    </p>
                    <p>
                        Let's start with the same <code>User</code> class, without any Jackson annotations:
                    </p>
                    <p>
                        <div>
                            <p>
                                <pre class="ace ace-java"
>public class User implements IUser {

    private String name;
    private String title;

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String getTitle() {
        return this.title;
    }

    @Override
    public void setTitle(String title) {
        this.title = title;
    }
}</pre> 
                            </p>
                        </div>   
                    </p>
                    
                    <p>
                        To use XML mix-ins in a Spincast application,
                        you first need to create the mix-in <em>abstract class</em>. Interfaces work too, but
                        only to annotate methods, not fields.
                    </p>
                    <p>
                        An example mix-in for our <code>IUser</code> objects:
                        <div>
                            <p>
                                <pre class="ace ace-java" data-ace-hi="4,4,4,15"
>public abstract class IUserMixin implements IUser {

    // Ignore this property!
    @Override
    @JsonIgnore
    public abstract String getTitle();
}</pre> 
                            </p>
                        </div>   
                    </p>
                    <p>
                        As you can see, a mix-in extends the class/interface to configure, and adds
                        the Jackson annotations on the overriding fields or methods declarations.
                    </p>
                    <p>
                        Once the mix-in is defined, you have to register it, in your custom
                        Guice module:
                    </p>
                    <p>
                        <div>
                            <p>
                                <pre class="ace ace-java"
>public class AppModule extends SpincastDefaultGuiceModule {

    public AppModule(String[] mainArgs) {
        super(mainArgs);
    }

    @Override
    protected void configure() {
        super.configure();

        bindXmlMixins();
        
        //...
    }

    protected void bindXmlMixins() {

        Multibinder&lt;IXmlMixinInfo&gt; xmlMixinsBinder = Multibinder.newSetBinder(binder(), IXmlMixinInfo.class);
        xmlMixinsBinder.addBinding().toInstance(new XmlMixinInfo(IUser.class, IUserMixin.class));
    }
}</pre> 
                            </p>
                            <p>
                                <span class="explanation">Explanation :</span>
                                <ul>
                                    <li>
                                        <span class="code-line-nbr">18</span> : A 
                                        <a href="https://github.com/google/guice/wiki/Multibindings">multibinder</a> is used
                                        to <em>collect</em> the various mix-ins to register. The advantage of a multibinder
                                        is that it allows to register mix-ins from <em>any</em> Guice module. For example, some
                                        plugins may want to register their mix-ins, and you may want to register your custom ones.
                                    </li>
                                    <li>
                                        <span class="code-line-nbr">19</span> : We register our mix-in, by binding a
                                        <code>XmlMixinInfo</code> instance, which specifies the class to configure, and the 
                                        class of the mix-in used to configure it.
                                    </li>
                                </ul>
                            </p> 
                                        
                        </div>   
                    </p> 
                    <p>
                        With this in place, Spincast will automatically configure Jackson so it uses your mix-ins, and 
                        you would have the exact same result than annotating the <code>User</code>
                        class directly:
                        <div>
                            <p>
                                <pre class="ace ace-java"
>IUser user = new User();
user.setName("Stromgol");
user.setTitle("alien");

String xml = getXmlManager().toXml(user);
assertNotNull(xml);
assertEquals("&lt;User&gt;&lt;name&gt;Stromgol&lt;/name&gt;&lt;/User&gt;", xml);</pre> 
                            </p>
                        </div>   
                    </p> 
                    
                </div> 
            </section>


        </div>
    </div>
    
</div> 

{% endblock %}