{#==========================================
Docs : "Routing"
==========================================#}

{#==========================================
Routing
==========================================#}     
<section id="routing">
    <h3>
        <a class="anchor" href="#routing" title="permanent link"></a>
        Routing
    </h3>
    
    <p>
        Let's learn how the routing process works in Spincast, and how to create
        Routes and Filters.
    </p>
    
    {#==========================================
    Section "routing / The routing process"
    ==========================================#}
    <div id="routing_process">
        <h4>
            <a class="anchor_small" href="#routing_process" title="permanent link"></a>
            The Routing Process
        </h4>
        
        <p>
            When an HTTP request arrives, the Router is asked to find what <code>Route Handlers</code> should be used to handle it.
            There can be more than one <code>Route Handler</code> for a single request because of <code><em>Filters</em></code> :
            <code>Filters</code> are standard <code>Route Handlers</code>, but that run <em>before</em> or <em>after</em> the <code>main Route Handler</code>.
        </p> 
        <p>
            There can be only <em>one</em> <code>main Route Handler</code> but multiple 
            <em>before</em> and <em>after</em> <code>Filters</code>. Even if multiple <code>Route Handlers</code> would match
            a request, the router will only pick one as the <em>main</em> one (by default, it keeps the first one matching).
        </p> 
        <p>
            Those matching <code>Routes Handlers</code> are called in a
            specific order. As we'll see in the <a href="#filters"><code>Filters</code></a> section, a
            <code>Filter</code> can have a <code><em>position</em></code></code> which indicates <em>when</em> the <code>Filter</code> should run. So it is
            possible to specify that we want a <code>Filter</code> to run before or after another one. 
        </p> 
        <p>
            This initial routing process has a <a href="#routing_types"><em>routing process type</em></a> called <code>"Found"</code>. 
            The <code>"Found"</code> routing
            type is the one active when at least one <code>main Route Handler</code> matches the request. This is the most frequent case,
            when valid requests are received, using URLs that are managed by our application.
        </p> 
        <p>
            But what if no <code>main Route Handler</code> matches? What if we receive a request that uses an invalid URL? Then, 
            we enter a routing process with a <code>routing process type</code> called <code><em>"Not Found"</em></code> (404). We'll see in the 
            <a href="#routing_types">Routing Types</a> section that we can define some routes
            as dedicted to the <code>Not Found</code> routing process. Those routes are the ones that are 
            going to be considered when a <code>Not Found</code> routing process occures.
        </p> 
        <p>    
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            So when we receive a request for an invalid URL, the <code>Not Found</code> routing process
            is triggered and the dedicated Routes are considered as potential handlers.
            But that <code>Not Found</code> routing process can also be activated if a 
            <a class="javadoc" href="/public/javadoc/org/spincast/core/exceptions/NotFoundException.html"><code>NotFoundException</code></a> is 
            thrown in our application! Suppose you have a <code>"/users/${userId}"</code> Route, and a 
            request for <code>"/users/42"</code> is received... Then a <code>main Route Handler</code> may be found and called,
            but it is possible that this particular user, with id <code>"42"</code>, <em>is not found in the system</em>...
            Your can at this point throw a <code>NotFoundException</code> exception : this is going to stop the initial
            <code>"Found"</code> routing process, and start a new <code>Not Found</code> routing process, as if the request
            was using an invalid URL in the first place!
        </p> 
        <p>
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            The third and final routing process type (with <code>"Found"</code> and <code>"Not Found"</code>) is <code><em>"Exception"</em></code>.
            If an exception occurs during a <code>"Found"</code> or a <code>"Not Found"</code>
            routing process, then a new <code>"Exception"</code> routing process is started. This
            enables you to create some Routes explicitly made to manage exceptions.
        </p> 
        <p>
            It's important to note that there are some <a href="#special_exceptions">special exceptions</a> which may have a different
            behavior though. The best example is the <code>NotFoundException</code> exception we already discussed : this exception,
            when throw, doesn't start a new <code>"Exception"</code> routing process, but a new <code>"Not Found"</code>
            routing process.  
        </p> 
        <p>
            Also note that if you do not define custom <code>"Not Found"</code> and <code>"Exception"</code>
            <code>Routes Handlers</code>, some basic ones are provided. It is still highly recommended that you
            create custom ones.
        </p>
        <p> 
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            There are two important things to remember about how a routing process works :
            
            <ul>
                <li>
                    <p>
                        When a routing process starts, the process of finding the matching Routes is restarted <em>from the beginning</em>.
                        For example, if you have some "before" <code>Filters</code> that
                        have already been run during an initial <code>"Found"</code> routing process, and then your <code>main Route Handler</code> 
                        throws an exception, the routing process <em>will be restarted</em> (this time of type <code>"Exception"</code>) and 
                        those already ran <code>Filters</code> may be run again if they are also part of the new routing process!
                    </p> 
                    <p>
                        The only difference between the initial routing process and the
                        second one is the <code>type</code> which will change the Routes that are going to
                        be considered. Only the Routes that have been configured to support the
                        <code>routing process type</code> of the current routing process may match.
                    </p> 
                </li>
                <li>
                    When a new routing process starts, the current response <em>is reset</em> : its
                    buffer is emptied, and the HTTP headers are reset... But this is only true if the response
                    has not already been <a href="#sending_response_flushing">flushed</a> though!
                </li>  
            </ul>
        </p> 
        <p>
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            Finally, note that Spincast also supports WebSockets, which involve a totally
            different routing process! Make sure you read the dedicated section about
            <a href="#websockets">WebSockets</a> to learn more about this.
        </p>

    </div>
    
    {#==========================================
    Section "routing / Adding a route"
    ==========================================#}
    <div id="adding_route">
        <h4>
            <a class="anchor_small" href="#adding_route" title="permanent link"></a>
            Adding a Route
        </h4>
        
        <p>
            Now, let's learn how to define our Routes!
        </p>
        <p>
            First, you have to get the <code>Router</code> instance. If you use the default router, this
            involves injecting the <a class="javadoc" href="/public/javadoc/org/spincast/plugins/routing/DefaultRouter.html">DefaultRouter</a>
            object. For example, using constructor injection :
            
            <div>
                <p>
                    <pre class="ace ace-java"
>public class AppRouteDefinitions {

    private final DefaultRouter router;
    
    @Inject
    public AppRouteDefinitions(DefaultRouter router) {
        this.router = router;
    }
    
    //...
}</pre> 
                </p>
            </div>
            
            On that Router,
            there are methods to create a <code><em>Route Builder</em></code>. As its name indicates,
            this object uses a <em>builder pattern</em> to help you create a Route. Let's see that in details...
        </p>
    </div>
    
    {#==========================================
    Section "routing / HTTP method and path"
    ==========================================#}
    <div id="http_method_and_path">
        <h4>
            <a class="anchor_small" href="#http_method_and_path" title="permanent link"></a>
            HTTP method and path
        </h4>
    
        You create a Route Builder by choosing the <code>HTTP methods</code> 
        and the <code>path</code> you want your Route to handle :
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>

router.GET("/") ...

router.POST("/users") ...

router.DELETE("/users/${userId}") ...

// Handles all HTTP methods
router.ALL("/books") ...

// Handles POST and PUT requests only
router.SOME("/books", HttpMethod.POST, HttpMethod.PUT) ...
</pre> 
                </p>
            </div>
        </p>  
    </div>  
    
    {#==========================================
    Section "routing / Route id"
    ==========================================#}
    <div id="route_id">
        <h4>
            <a class="anchor_small" href="#route_id" title="permanent link"></a>
            Route id
        </h4>
    
        You can assign an <code>id</code> to a route. This id can be useful later, for example
        to validate at runtime what the route of the current request is.
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>

router.GET("/users").id('users') ...
</pre> 
                </p>
            </div>
        </p>  
    </div>  
    
    
    {#==========================================
    Section "routing / Dynamic parameters"
    ==========================================#}
    <div id="dynamic_parameters">
        <h4>
            <a class="anchor_small" href="#dynamic_parameters" title="permanent link"></a>
            Dynamic parameters
        </h4>
    
        In the paths of your route definitions, you can use what we call <code>"dynamic parameters"</code>,
        which syntax is <code>"${<em>paramName</em>"</code>}.
        For example, the following Route Builder will generate a Route matching any request for an
        URL starting with <code>"/users/"</code> and that is followed by another token:
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>router.GET("/users/${userId}")
</pre> 
                </p>
            </div>
        </p>
        <p>
            By doing so, your associated <code>Route Handlers</code> can later access the actual value of this 
            dynamic parameter. For example : 
        </p>
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>public void myHandler(AppRequestContext context) {
    
    String userId = context.request().getPathParam("userId");
    
    // Do something with the user id...
}</pre> 
                </p>
            </div>
        </p>
        <p>
            If a <code>"/users/42"</code> request is received, then the <code>userId</code> would be <code><em>"42"</em></code>, in this
            example.
        </p>
        <p>
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            Note that this <code>"/users/${userId}"</code> example will only match
            URLs containing <em>exactly two tokens</em>! An URL like <code>"/users/42/book/123"</code> 
            won't match!
        </p>
        <p>
            If you want to match more than one path tokens using a single variable, you have to use a
            <code>Splat parameter</code>, which syntax is <code>"*{<em>paramName</em>}"</code>. 
            For example, the Route generated in following example
            <em>will</em> match both <code>"/users/42"</code> and <code>"/users/42/book/123"</code> :
            
            <div>
                <p>
                    <pre class="ace ace-java"
>router.GET("/users/${userId}/*{remaining}")</pre> 
                </p>
            </div>
            
        </p>
        <p>
            In this example, the <code>Route Handlers</code> would have access to <em>two</em> path parameters :
            <code>userId</code> will be <code><em>"42"</em></code>, and <code>remaining</code> will
            be <code><em>"book/123"</em></code>.
        </p>
        <p>
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            A dynamic parameter can also contain a regular expression pattern. The
            syntax is <code>"${paramName:<em>pattern</em>}"</code>, where "pattern" is the regular expression
            to use. For example :
        </p>
        <p>
            <div>
                <p>
                    <pre class="ace ace-java" data-ace-hi="1,28,1,32"
>

router.GET("/users/${userId:\\d+}")
</pre> 
                </p>
            </div>
            
            In this example, only requests starting with <code>"/users/"</code> and followed by a <em>numeric value</em> 
            will match. In other words, <code>"/users/1"</code> and <code>"/users/42"</code> would match, 
            but <em>not</em> <code>"/users/abc"</code>.    
        </p>
        <p>
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            Finally, a dynamic parameter can also contain what we call a <code><em>pattern alias</em></code>.
            Instead of having to type the regular expression pattern each time you need it, you can 
            use an <em>alias</em> for it. The syntax to use an alias is <code>"${paramName:&lt;<em>alias</em>&gt;}"</code>.
        </p>
        <p>
            Spincast has some <em>built-in</em> aliases :
        </p>
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>
// Matches only alpha characters (A to Z)
router.GET("/${param1:&lt;A&gt;}")

// Matches only numeric characters (0 to 9)
router.GET("/${param1:&lt;N&gt;}")

// Matches only alphanumeric characters (A to Z) and (0 to 9)
router.GET("/${param1:&lt;AN&gt;}")

// Matches only alpha characters (A to Z), "-" and "_"
router.GET("/${param1:&lt;A+&gt;}")

// Matches only numeric characters (0 to 9), "-" and "_"
router.GET("/${param1:&lt;N+&gt;}")

// Matches only alphanumeric characters (A to Z), (0 to 9), "-" and "_"
router.GET("/${param1:&lt;AN+&gt;}")
</pre> 
                </p>
            </div>
        </p>
        <p>
            You can of course create your <em>own</em> aliases.
            You do that using the <code>addRouteParamPatternAlias(...)</code> method
            on the Router. For example :
        </p>
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>
// Registers a new alias
router.addRouteParamPatternAlias("USERS", "user|users|usr");

// Uses the alias! 
router.GET("/${param1:&lt;USERS&gt;}/${userId}")
</pre> 
                </p>
            </div>
        </p>
        <p>
            The Route generated using this pattern would match <code>"/user/123"</code>, <code>"/users/123"</code>
            and <code>"/usr/123"</code>, but not <code>"/nope/123"</code>.
        </p>
    </div>  
     
    {#==========================================
    Section "routing / Routing Types"
    ==========================================#}
    <div id="routing_types">
        <h4>
            <a class="anchor_small" href="#routing_types" title="permanent link"></a>
            Routing Process Types
        </h4>
        <p>
            You can specify of which <em>type</em> the current 
            <a href="#routing_process">routing process</a> 
            must be for your route to be considered. 
        </p>
        <p>
            The three <code>routing process types</code> are:
            <ul>
                <li>
                    <code>Found</code>
                </li>
                <li>
                    <code>Not Found</code>
                </li>
                <li>
                    <code>Exception</code>
                </li>
            </ul> 
        </p>
        <p>
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            If no <code>routing process type</code> is specified when a Route is created, <code>"Found"</code> is used by default.
            This means the Route won't be considered during a <code>Not Found</code> or <code>Exception</code> routing process.
        </p> 
        <p>
            Here's a example of creating Routes using routing process types :
            <div>
                <p>
                    <pre class="ace ace-java"
>
// Only considered during a "Found" routing process
// (this is the default, so it is not required to specify it)
router.GET("/").found() ...

// Only considered during a "Not Found" routing process
router.GET("/").notFound() ...

// Only considered during an "Exception" routing process
router.GET("/").exception() ...

// Always considered!
router.GET("/").allRoutingTypes() ...

// Considered both during a "Not Found"
// or an "Exception" routing process
router.GET("/").notFound().exception() ...
</pre>
                </p>
            </div>
        </p>
        <p>
            There are some shortcuts to 
            quickly define a Route for a <code>"Not Found"</code>
            or an <code>"Exception"</code> type, wathever the
            URL is :
        </p>
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>
// Synonym of : 
// router.ALL("/*{path}").notFound().save(handler)
router.notFound(handler);

// Synonym of : 
// router.ALL("/*{path}").exception().save(handler)
router.exception(handler);
</pre> 
                </p>
            </div>
        </p>
        
    </div>  

    {#==========================================
    Section "routing / Content-Types"
    ==========================================#}
    <div id="route_content-type">
        <h4>
            <a class="anchor_small" href="#route_content-type" title="permanent link"></a>
            Content-Types
        </h4>
        
        <p>
            You can specify for acceptable <code>content-types</code> for a Route to
            be considered. For example, you may have a <code>Route Handler</code> for a 
            <code><em>"/users"</em></code> URL that will
            produce <code>Json</code>, and another <code>Route Handler</code> that will produce
            <code>XML</code>, for the very same URL. You could also have a single handler
            for both content-types, and 
            let this handler decide what to return as the response : both approaches are valid.
        </p> 
        <p>
            If no <code>content-type</code> is specified when building a Route, 
            the route is always considered in that regard.
        </p> 
        
        <p>
            Let's see some examples :
            <div>
                <p>
                    <pre class="ace ace-java"
>
// Only considered if the request accepts HTML
router.GET("/users").html() ...

// Only considered if the request accepts Json
router.GET("/users").json() ...

// Only considered if the request accepts XML
router.GET("/users").xml() ...

// Only considered if the request accepts HTML or plain text
router.GET("/users").accept(ContentTypeDefaults.HTML, ContentTypeDefaults.TEXT) ...

// Only considered if the request accepts PDF
router.GET("/users").acceptAsString("application/pdf") ...
</pre> 
                </p>
            </div>
        </p>     
    </div>

    {#==========================================
    Section "routing / HTTP Caching"
    ==========================================#}
    <div id="route_http_caching">
        <h4>
            <a class="anchor_small" href="#route_http_caching" title="permanent link"></a>
            HTTP Caching route options
        </h4>
        
        <p>
            Soon in the documentation, you will find a dedicated <a href="#http_caching">HTTP Caching</a> section, 
            containing all the information about HTTP Caching using Spincast. Here, we're only going to list the options 
            available when building a Route.
        </p> 
        <p>
            For both regular Routes and Static Resources Routes, you can use the
            <code>cache(...)</code> method to send appropriate cache headers 
            to the client :
        </p> 
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>
// Default cache headers will be sent (this default is configurable).
router.GET("/test").cache() ...

// Sends headers so the client caches the resource for 60 seconds.
router.GET("/test").cache(60) ...

// Sends headers so the client caches the resource for 60 seconds.
// Also specifies that this cache should be *private*.
// See : https://goo.gl/VotTdD
router.GET("/test").cache(60, true) ...

// Sends headers so the client caches the resource for 60 seconds,
// but so a CDN (proxy) caches it for 30 seconds only.
router.GET("/test").cache(60, false, 30) ...

// The "cache()" method is also available on Static Resources Routes!
router.file("/favicon.ico").cache(86400).classpath("/public/favicon.ico") ...</pre> 
                </p>
            </div>
        </p>   
        <p>
        	<img class="inlineIcon" src="/public/images/icons/para.png" />
            On a standard route, it is also possible to use the <code>noCache()</code> 
            method to send headers asking the client to disable <em>any</em> caching :
        </p> 
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>
router.GET("/test").noCache().save(handler);
</pre> 
                </p>
            </div>
        </p>  
        <p>
        	
            Again, make sure you read the dedicated <a href="#http_caching">HTTP Caching</a> section for
            the full documentation about caching.
        </p> 
    </div>

    {#==========================================
    Section "routing / Saving"
    ==========================================#}
    <div id="route_saving">
        <h4>
            <a class="anchor_small" href="#route_saving" title="permanent link"></a>
            Saving the route
        </h4>
        
        <p>
            When your Route definition is complete, you save the generated Route to the <code>router</code> by passing
            a last parameter to the <code>save(...)</code> method : the <code>Route Handler</code> to use to handle the
            Route. With Java 8, you can use a <code>method handler </code>or a <code>lambda</code> for this parameter :
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>
// A method handler
router.GET("/").save(controller::indexHandler);

// A lambda expression
router.GET("/").save(context -> controller.indexHandler(context));
</pre> 
                </p>
            </div>
        </p>  
        <p>
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            Here's a complete example of a Route creation :
            
            <div>
                <p>
                    <pre class="ace ace-java"
>
// Will be considered on a GET request accepting Json or XML, when a 
// requested user is not found.
// This may occure if you throw a "NotFoundException" after you validated
// the "userId" path parameter...
router.GET("/users/${userId}").notFound().json().xml().save(usersController::userNotFound);
    </pre> 
                </p>
            </div>  
        </p>

    </div>
    
    {#==========================================
    Section "routing / Filters"
    ==========================================#}
    <div id="filters">
        <h4>
            <a class="anchor_small" href="#filters" title="permanent link"></a>
            Filters
        </h4>
        
        <p>
            <code>Filters</code> are plain <code>Route Handlers</code>, with the exception 
            that they run <em>before</em> or <em>after</em> the single <code>main Route Handler</code>.
        </p> 
        <p>
            You can declare a <code>Filter</code> exactly like you would declare a
            standard Route, but using the extra "<code><em>pos</em></code>" ("position") property! The
            <code>Filter</code>'s position indicate <em>when</em> the <code>Filter</code> should be run. The lower
            that position number is, the sooner the <code>Filter</code> will run. Note that the 
            <code>main Route Handlers</code> are considered as having a position of <code>"0"</code>, so <code>Filters</code>
            with a position below "0" are <em>before</em> <code>Filters</code>, and those with a 
            position greater than "0" are <em>after</em> <code>Filter</code>.
        </p> 
        <p>
            <div>
                <p>
                    An example :
                    <pre class="ace ace-java"
>
// This Filter is a "before" Filter and
// will be run first.
router.GET("/").pos(-3).save(ctl::filter1);

// ThisFilter is also a "before" Filter and
// will be run second.
router.GET("/").pos(-1).save(ctl::filter2);

// This is not a Filter, it's a main Route Handler 
// and the ".pos(0)" part is superfluous!
router.GET("/").pos(0).save(ctl::mainHandler);

// This Filter is an "after" Filter and will run
// after the main Route Handler
router.GET("/").pos(100).save(ctl::filter3);
</pre> 
                </p>
            </div>
        </p>  
        <p>
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            A Route definition can <em>disable</em> a Filter that would otherwise be run, by 
            using the <code>skip(...)</code> method. The target Filter must have
            been declared with an <code>"id"</code> for this to be possible though. He're
            an example :
            
            <div>
                <p>
                    <pre class="ace ace-java"
>
// This "myFilter" Filter will be applied on all Routes by default
router.ALL().pos(-100).id("myFilter").save(ctl::filter);

// ... but this Route disables it!
router.GET("/test").skip("myFilter").save(ctl::testHandler);
</pre> 
                </p>
            </div>
        </p>  
        <p>
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            You can also add inline Filters that are run only on
            <em>on a specific Route</em>, using the <code>before()</code> and
            <code>after()</code> methods :
        </p>  
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>// This route contains four "handlers" :
// two "before" Filters, the main Route Handler, 
// and one "after" Filter.
router.GET("/users/${userId}")
      .before(ctl::beforeFilter1)
      .before(ctl::beforeFilter2)
      .after(ctl::afterFilter)
      .save(ctl::mainHandler);</pre> 
                </p>
            </div>
        </p>  
        <p>
            The inline Filters don't have a position: they are
            run in the order they are declared! Also, they always run <em>just before</em>
            or <em>just after</em> the <code>main Route Handler</code>. In other words, they are always run closer to the
            <code>main Route Handler</code> than the <em>global</em> Filters. 
        </p>  
        <p>  
            The inline filters have access to the same<em> request information</em> than their 
            associated <code>main Route Handler</code>: same 
            <code>path parameters</code>, same <code>queryString parameters</code>, etc.
        </p> 
        <p>
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            Finally, note that a Filter can decide by itself if it will run or not,
            at runtime. For example, using the <code>routing()</code> add-on,
            a Filter can know if the current <a href="#routing_types">Routing Process Type</a> is 
            <code>"Found"</code>, <code>"Not Found"</code>
            or <code>"Exception"</code>, and decide to run or not depending on that information. 
            For example :
            
            <div>
                <p>
                    <pre class="ace ace-java"
>public void myFilterHandler(AppRequestContext context) {

    // The current Routing Process Type is "Exception",
    // we don't run the Filter.
    if(context.routing().isExceptionRoute()) {
        return;
    }

    // Or, using any other information from the request...
    
    // Some Cookie is set, we don't run the Filter.
    if(context.request().getCookie("someCookie") != null) {
        return;
    }

    // Actually run the Filter...
    
}</pre> 
                </p>
            </div>   
        </p> 
    </div>
    
    {#==========================================
    Section "routing / WebSockets"
    ==========================================#}
    <div id="routing_websockets">
        <h4>
            <a class="anchor_small" href="#routing_websockets" title="permanent link"></a>
            WebSockets
        </h4>
        <p>
            Because of the particular nature of <a href="https://en.wikipedia.org/wiki/WebSocket"><em>WebSockets</em></a>, we decided 
            to aggregate all the documentation about them 
            in a dedicated <a href="#websockets">WebSockets</a> section.
            Make sure you read that section to learn everything about WebSockets... Here's we're only
            going to provide a  quick WebSocket route definition example, since we're talking about routin.
        </p> 
        <p>
            To create a WebSocket Route, you use the <code>Router</code> object, the same way you do for a regular Route. The big
            difference is the <em>type of controller</em> that is going to receive the WebSocket request. Here's the quick example :
        </p> 
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>router.websocket("/chat").before(someFilter).save(chatWebsocketController);</pre> 
                </p>
            </div>
        </p>  
        
    </div>
    

    {#==========================================
    Section "routing / Static resources"
    ==========================================#}
    <div id="static_resources">
        <h4>
            <a class="anchor_small" href="#static_resources" title="permanent link"></a>
            Static Resources
        </h4>
        
        <p>
            You can tell Spincast that some files and directories are
            <code><em>Static Resources</em></code>.
            Doing so, those files and directories will be served by the HTTP Server <em>directly</em> :
            the requests for them won't even reach the framework.
        </p> 
        <p>
            Note that queryStrings are ignored when a request is made for a Static Resource. If you need
            queryStrings to make a difference, have a look at <a href="#dynamic_resources">Dynamic Resources</a>.
        </p> 

        <p>
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            Static Resources can be on the classpath or on the file system. For example:
        </p> 
        
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>
// Will serve all requests starting with the
// URL "/public" with files under the classpath
// directory "/public_files".
router.dir("/public").classpath("/public_files").save();

// Uses an absolute path to a directory on the file system  
// as a static resources root.
router.dir("/public").pathAbsolute("/user/www/myprojet/public_files").save();

// Uses a path relative to the Spincast writable directory, 
// on the file system, as the root for the static resources.
router.dir("/public").pathRelative("/public_files").save();

// Will serve the requests for a specific file,
// here "/favicon.ico", using a file from the classpath.
router.file("/favicon.ico").classpath("/public/favicon.ico").save();

// Uses an absolute path to a file on the file system 
// as the static resource target.
router.file("/favicon.ico").pathAbsolute("/user/www/myprojet/public_files/favicon.ico").save();

// Uses a path relative to the Spincast writable directory, 
// on the file system, as the static resource target file.
router.file("/favicon.ico").pathRelative("/public_files/favicon.ico").save();

</pre> 
                </p>
            </div>
        </p> 
        <p>
        	<img class="inlineIcon" src="/public/images/icons/para.png" /> 
            Be aware that since requests for Static Resources don't reach the framework, <em>Filters don't apply to them</em>! Even a
            "catch all" Filter such as <code>router.ALL().pos(-1).save(handler)</code> 
            won't be applied...
        </p> 
        <p>
            For the same reason, there are some limitations about the <a href="#dynamic_parameters">dynamic parameters</a> 
            that the Route definition of a Static Resource can contain... For standard Static Resources, only a <code>dir(...)</code>
            definition can contain a dynamic part, and it can only be
            a <code><em>splat parameter</em></code>, located at the very end of its route. For example :
            <ul>
                <li>
                    This is valid! : <code>dir(/one/two/*{remaining})</code>
                </li>
                <li>
                    This is <em>not valid</em> : <code>dir(/one/*{remaining}/two)</code>
                </li>
                <li>
                    This is <em>not valid</em> : <code>dir(/${param})</code>
                </li>
                <li>
                    This is <em>not valid</em> : <code>file(/one/two/*{remaining})</code>
                </li> 
            </ul>
        </p>
        <p>
        	<img class="inlineIcon" src="/public/images/icons/para.png" /> 
            Note that a <code>file(...)</code> resource has priority over of a <code>dir(...)</code> resource since
            it is more precise. For example, let's examine those two Route definitions :
        </p> 
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>
router.dir("/public").cache(3600).classpath("/public_files").save();
router.file("/public/test.txt").cache(60).classpath("/public_files/test.txt").save();
</pre> 
                </p>
            </div>
        </p> 
        <p>
            Even if the <code>"test.txt"</code> file is under the <code>"/public"</code> directory,
            a cache of <code>60</code> seconds will be applied, not <code>3600</code>.
        </p> 
        <p>
        	<img class="inlineIcon" src="/public/images/icons/para.png" /> 
            Finally, note that the Static Resource route definitions have <em>precedence</em> over any other
            Routes, so if you declare <code>router.dir("/", "/public")</code> for example, then
            <em>no Route at all will ever reach the framework</em>, everything would be considered
            as static! 
        </p> 
        <p>
            <img class="inlineIcon" src="/public/images/icons/tipy.png" />
            This is, by the way, a quick and easy way to serve a purely static 
            website using Spincast!
        </p> 
    </div>
    
    {#==========================================
    Section "routing / Dynamic resources"
    ==========================================#}
    <div id="dynamic_resources">
        <h4>
            <a class="anchor_small" href="#dynamic_resources" title="permanent link"></a>
            Dynamic Resources
        </h4>

        <p>
            A variation on <code>Static Resources</code> is what we call <code><em>Dynamic Resources</em></code>. When you
            declare a Static Resource, you can provide a <code><em>"generator"</em></code>. The <code>generator</code> is a 
            standard <code>Route Handler</code> that is going to receive 
            the request <em>if a requested Static Resource is not found</em>. The job of this <code>generator</code> is to
            generate the missing Static Resource and to return it as the response. Spincast will then automatically
            intercept the body of this response, save it, and next time this Static Resource is requested,
            it is going to be served directly by the HTTP server, without reaching the framework anymore!
        </p>
        <p>
            Here's an example of a Dynamic Resource definition :
            <div>
                <p>
                    <pre class="ace ace-java"
>router.dir("/images/tags/${tagId}").pathAbsolute("/generated_tags")
      .save(new DefaultHandler() {

          @Override
          public void handle(DefaultRequestContext context) {
    
              String tagId = context.request().getPathParam("tagId");
              byte[] tagBytes = generateTagImage(tagId);
    
              context.response().sendBytes(tagBytes, "image/png");
          }
      });</pre> 
                </p>
            </div>
        </p> 
        <p>
            Or, for a single file :
        </p>
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>router.file("/css/generated.css")
      .pathAbsolute("/user/www/myprojet/public_files/css/generated.css")
      .save(new DefaultHandler() {

          @Override
          public void handle(DefaultRequestContext context) {

              String css = generateCssFile(context.request().getRequestPath());
              context.response().sendCharacters(css, "text/css");
          }
      });</pre> 
                </p>
            </div>
        </p> 
        <p>
            Dynamic Resources definitions must be define using <code>.pathAbsolute(...)</code> or 
            <code>.pathRelative(...)</code>, and not <code>.classpath(...)</code> since the
            resource will be written to disk once generated. For the same reason, Spincast must have 
            write permissions on the target directory!
        </p>
        <p>
        	<img class="inlineIcon" src="/public/images/icons/para.png" /> 
            By default, if the request for a Dynamic Resource contains a
            queryString, <em>the resource is always generated</em>, no cached version is used!
            This allows you to generate a Static Resource which is going to be cached, but also to
            get a variation on this resource if required, by passing some parameters.
        </p>
        <p>
            Using the previous example, <code>"/css/generated.css"</code> requests would always return the
            same generated resource (only reaching the framework the first time), 
            but a <code>"/css/generated.css<strong>?test=123</strong>"</code> request
            would not use any cached version and would always reach your generator.
        </p>
        <p>
        	If you don't want a queryString to make a difference, if you always
            want the first generated resource to be cached and served, you can set the
            <code>"ignoreQueryString"</code> parameter to <code>true</code> :
            
            <div>
                <p>
                    <pre class="ace ace-java" data-ace-hi="10,9,10,13"
>router.file("/css/generated.css")
      .pathAbsolute("/user/www/myprojet/public_files/css/generated.css")
      .save(new DefaultHandler() {

          @Override
          public void handle(DefaultRequestContext context) {

              String css = generateCssFile(context.request().getRequestPath());
              context.response().sendCharacters(css, "text/css");
          }
      }, true);
</pre> 
                </p>
            </div>
            
            Doing so, <code>"/css/generated.css"</code> and 
            <code>"/css/generated.css<strong>?test=123</strong>"</code>
            would both always return the same cached resource.
        </p> 
        
        <p>
        	<img class="inlineIcon" src="/public/images/icons/para.png" /> 
            The Route of a Dynamic Resource can contain
            <a href="#dynamic_parameters">dynamic parameters</a>, but there are some rules :
        </p> 
        <p>
        	<ul>
        		<li>
        			The Route of a <code>file(...)</code> based Dynamic Resource can contain 
                    dynamic parameters but no <em>splat parameter</em>.
        			For example :
			        <p>
			            <div>
			                <p>
			                    <pre class="ace ace-java" data-ace-hi="1,19,1,30"
>

router.file("/test/${fileName}").pathAbsolute("/usr/someDir/${fileName}").save(generator);
</pre> 
			                </p>
			            </div>
			        </p> 
        		</li>
        		<li>
        			The Route of a <code>dir(...)</code> based Dynamic Resource can only contain a <em>splat parameter</em>, at its end.
        			For example :
			        <p>
			            <div>
			                <p>
			                    <pre class="ace ace-java" data-ace-hi="1,23,1,31"
>

router.dir("/generated/*{splat}").pathRelative("/someDir").save(generator);
</pre> 
			                </p>
			            </div>
			        </p> 
        		</li>
        		<li>
        			The <em>target path</em> of a <code>file(...)</code> based Dynamic Resource <em>can</em> use the dynamic parameters
        			from the URL. For example this is valid :
			        <p>
			            <div>
			                <p>
			                    <pre class="ace ace-java" data-ace-hi="1,60,1,71"
>

router.file("/test/${fileName}").pathAbsolute("/usr/someDir/${fileName}").save(generator);
</pre> 
			                </p>
			            </div>
			        </p> 
        		</li>
        		<li>
        			But the <em>target path</em> of a <code>dir(...)</code> based Dynamic Resource <em>can not</em> use 
                    the <code>splat parameter</code>
        			from the URL :
			        <p>
			            <div>
			                <p>
			                    <pre class="ace ace-java" data-ace-hi="1,57,1,65"
>// This is NOT valid!
router.dir("/generated/*{splat}").pathAbsolute("/someDir/*{splat}").save(generator);
</pre> 
			                </p>
			            </div>
			        </p> 
        		</li>
        	</ul>
        </p> 
        
    </div>
    
    {#==========================================
    Section "routing / CORS"
    ==========================================#}
    <div id="cors">
        <h4>
            <a class="anchor_small" href="#cors" title="permanent link"></a>
            CORS
        </h4>

        <p>
            CORS, <em><a href="http://www.html5rocks.com/en/tutorials/cors/">Cross-Origin Resource Sharing</a></em>, allows you to
            specify some resources in your application that can be accessed by a browser <em>from another domain</em>. For example,
            let's say your Spincast application runs on domain <code>http://www.example1.com</code>, and you want to allow another
            site, <code>http://www.example2.com</code>, to access some of your APIs, or some of your files. By default, 
            browsers don't allow such cross domains requests. You have to enable <code>CORS</code>
            for them to work.
        </p>
        <p>
            There is a provided <code>Filter</code> to enable CORS on regular Routes. Since <code>Filters</code>
            are not applied to <code>Static Resources</code>, there is also a special configuration to add
            <code>CORS</code> to those :
        </p>
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>// Enable CORS for every Routes of the application,
// except for Static Resources.
getRouter().cors();

// Enable CORS for all Routes matching the specified path,
// except for Static Resources.
getRouter().cors("/api/*{path}");

// Enable CORS on a Static Resource directory.
getRouter().dir("/public").classpath("/public_files")
           .cors().save();
           
// Enable CORS on a Static Resource file.
getRouter().file("/public/test.txt").classpath("/public_files/test.txt")
           .cors().save();</pre> 

                </p>
            </div>
        </p> 
        <p>
            Here are the available options when configuring CORS on a Route :
            <div>
                <p>
                    <pre class="ace ace-java"
>
// The default :
// - Allows any origins (domains)
// - Allows cookies
// - Allows any HTTP methods (except for Static Resources,
//   which allow GET, HEAD and OPTIONS only)
// - Allows any headers to be sent by the browser
// - A Max-Age of 24h is specified for caching purposes
//
// But :
// - Only basic headers are allowed to be read from the browser.
.cors()

// Like the default, but also allows some extra headers
// to be read from the browser. 
.cors(Sets.newHashSet("*"),
      Sets.newHashSet("extra-header-1", "extra-header-2"))

// Only allows the domains "http://example2.com" and "https://example3.com" to access 
// your APIs.
.cors(Sets.newHashSet("http://example2.com", "https://example3.com"))

// Like the default, but only allows the specified extra headers
// to be sent by the browser.
.cors(Sets.newHashSet("*"),
      null,
      Sets.newHashSet("extra-header-1", "extra-header-2"))

// Like the default, but doesn't allow cookies.
.cors(Sets.newHashSet("*"),
      null,
      Sets.newHashSet("*"),
      false)

// Like the default, but only allows the extra "PUT" method
// in addition to GET, POST, HEAD and OPTIONS 
// (which are always allowed). Not applicable to
// Static Resources.
.cors(Sets.newHashSet("*"),
      null,
      Sets.newHashSet("*"),
      true,
      Sets.newHashSet(HttpMethod.PUT))

// Like the default, but specifies a Max-Age of 60 seconds
// instead of 24 hours.
.cors(Sets.newHashSet("*"),
      null,
      Sets.newHashSet("*"),
      true,
      Sets.newHashSet(HttpMethod.values()),
      60)
</pre> 
                </p>
            </div>
        </p> 
    </div>
    
    {#==========================================
    Section "routing / HTTP Authentication"
    ==========================================#}
    <div id="http_auth">
        <h4>
            <a class="anchor_small" href="#http_auth" title="permanent link"></a>
            HTTP Authentication
        </h4>

        <p>
            If you need a section of your application to be protected so only privileged users
            can access it, one of the options is to use 
            <code>HTTP Authentication</code>. With <code>HTTP Authentication</code>, the <code>Server</code> itself
            manages the authentication, so no request will ever reach the
            framework or a protected resource unless the correct username/password is given.
        </p>
        <p>
            Here's a <img class="inlineIcon" src="/public/images/icons/run.png" /><a href="/demos-tutorials/http-authentication/protected">Protected page example</a>. To access it, you have
            to provide the correct username/password combination: <code>Stromgol</code>/<code>Laroche</code>.
        </p>
        <p>
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            You enable <code>HTTP Authentication</code> in two steps :
            
            <ul>
                <li>
                    You use the <code>httpAuth(...)</code> method on the <code>Router</code>
                    object to indicate which sections of the application to protect. This method requires 
                    the base URL of the section to protect and a name  for the <code>realm</code>  
                    (a synonym for <em>"a protected section"</em>) :
                    
                    <div>
                        <p>
                            <pre class="ace ace-java"
>// Protects the "/admin" section of the website and associates
// a realm name
router.httpAuth("/admin", "Protected Admin Section");</pre> 
                        </p>
                    </div> 
                    
                    Note that the name of the <code>realm</code> will be 
                    displayed to the user when the server asks for the username/password!
                </li>
                <li>
                    You add a set of acceptable username/passwords combinaisons for that
                    realm, using the <code>addHttpAuthentication(...)</code> on the
                    <code>Server</code> object :
                    
                    <div>
                        <p>
                            <pre class="ace ace-java"
>// Adds a username/password combinaison to the
// "Protected Admin Section" realm
getServer().addHttpAuthentication("Protected Admin Section", "Stromgol", "Laroche")</pre> 
                        </p>
                    </div>
                    If you fail to add any username/password combinaisons,
                    no one will be able to see the protected section!
                </li>
            </ul>
        </p>
        <p>
            You can have a look at the Javadoc of the 
            <a class="javadoc" href="/public/javadoc/index.html?org/spincast/core/server/Server.html">server</a>
            to see more methods related to <code>HTTP Authentication</code>.
        </p>
        <p>
            <img class="inlineIcon" src="/public/images/icons/para.png" /> 
            Finally, note that <code>HTTP Authentication</code> is a quick and easy way to protect a section
            of your application but, if you need more flexibility, a <code>form based</code> authentication is often
            preferred.
        </p>
    </div>
    
    
    {#==========================================
    Section "routing / Redirection rules"
    ==========================================#}
    <div id="redirections">
        <h4>
            <a class="anchor_small" href="#redirections" title="permanent link"></a>
            Redirection rules
        </h4>

        <p>
            Using the Router, you can specify that a Route must automatically be redirected 
            to another one. This is
            useful, for example, when you change the URL of a resource but don't want the
            existing links to break.
        </p>
        <p>
            To add a redirection rule, simply use the <code>redirect(...)</code> method on the Router:
        </p> 
        <p>
            <div>
                <p>
                    <pre class="ace ace-java"
>
router.redirect("/the-original-route").to("/the-new-route");
</pre> 

                </p>
            </div>
        </p> 
        <p>
            Here are the available options when creating such redirection rule:
            
            <ul>
            	<li>
            		<code>redirect(<em>originalRoute</em>)</code>: starts the creation of the direction rule
            		by specifying the original Route's path.
            	</li>
            	<li>
            		<code>temporarily()</code>: specifies that the redirection must be temporary (<code>302</code>).
            	</li>
            	<li>
            		<code>permanently()</code>: specifies that the redirection must be permanent (<code>301</code>). This
            		is the default and it is not required to specify it.
            	</li>
            	<li>
            		<code>to(<em>newRoute</em>)</code>: saves the redirection rule by specifying the new Route's path.
            	</li>
            </ul>
        </p> 
        <p>
        	<img class="inlineIcon" src="/public/images/icons/para.png" /> 
            Note that if the path of the original Route contains <a href="#dynamic_parameters">dynamic parameters</a>
            (splat parameters included), you can use those in the definition of the new Route! 
            For example, this redirection rule will redirect
            <code class="block">"/books/42"</code> to <code>"/catalog/item/42"</code> :
            
            <div>
                <p>
                    <pre class="ace ace-java"
>router.redirect("/books/${bookId}").to("/catalog/item/${bookId}");</pre> 
                </p>
            </div>
        </p> 
        <p>
        	Those dynamic parameters can be used <em>anywhere</em> in the new Route definition, not
        	just as "full" tokens. For example, this redirection rule will redirect
            <code class="block">"/types/books/42"</code> to <code>"/catalog-books/42"</code> :
            
            <div>
                <p>
                    <pre class="ace ace-java"
>router.redirect("/types/${typeId}/${itemId}").to("/catalog-${typeId}/${itemId}");</pre> 
                </p>
            </div>
        </p> 
        <p>
        	<img class="inlineIcon" src="/public/images/icons/para.png" /> 
            Finally, note that a redirection rule is implemented as a "before" <code>Filter</code> and
            must, in general, be the very first one to run! Its position is configurable using
            <a class="javadoc" href="/public/javadoc/org/spincast/plugins/routing/SpincastRouterConfig.html">SpincastRouterConfig</a> and 
            its default value is <code>"-1000"</code>.
            When this <code>Filter</code> runs, any other <code>Filters</code> or <code>Route Handlers</code> are skipped, 
            and the redirection header is sent to the client immediately.
        </p> 
        
    </div>

    {#==========================================
    Section "routing / Special exceptions"
    ==========================================#}
    <div id="special_exceptions">
        <h4>
            <a class="anchor_small" href="#special_exceptions" title="permanent link"></a>
            Special exceptions
        </h4>
        <p>
            You can throw any exception and it is going to trigger a new <code>"Exception"</code> <a href="#routing_process">routing process</a>.
            But some exceptions provided by Spincast have a special behavior :
        <p>
        <p>
            <ul>
                <li>
                    <a class="javadoc" href="/public/javadoc/org/spincast/core/exceptions/RedirectException.html">RedirectException</a> : This exception 
                    will stop the current routing process (as any exception does),
                    will <em>send a redirection header to the user</em>, and will end the exchange. Learn
                    more about that in the <a href="#sending_response_redirecting">Redirecting</a> section.
                    Here's an example :
 
                    <p>
                        <div>
                            <p>
                                <pre class="ace ace-java"
>public void myHandler(AppRequestContext context) {

    // Redirects to "/new-url"
    throw new RedirectException("/new-url", true);
    
    // You can also provide a Flash message :
    throw new RedirectException("/new-url", true, myFlashMessage);
}</pre> 
                            </p>
                        </div>
                    </p> 
                </li>
                <li>
                    <a class="javadoc" href="/public/javadoc/org/spincast/core/exceptions/ForwardRouteException.html">ForwardRouteException</a> : 
                    This exception allows
                    you to change the Route, <em>to forward the request</em>
                    to another Route without any client side redirection. Doing so, a new
                    <a href="#routing_process">routing process</a> is started, but this time using the 
                    newly specified URL.
                    Learn more about this in the <a href="#sending_response_forwarding">Forwarding</a> section.
                    Here's an example :
                        <div>
                            <p>
                                <pre class="ace ace-java"
>public void myHandler(AppRequestContext context) {

    throw new ForwardRouteException("/new-url");
}</pre> 
                            </p>
                        </div>
                </li>
                <li>
                    <a class="javadoc" href="/public/javadoc/org/spincast/core/exceptions/SkipRemainingHandlersException.html">SkipRemainingHandlersException</a> : 
                    This exception stops
                    the current <code>routing process</code>, but <em>without starting any new one</em>. In other words, the
                    remaining <code>Filters</code>/<code>Route Handlers</code> won't be run, and the <code>response</code> will be
                    sent as is, without any more modification. Learn more about this in the
                    <a href="#sending_response_skip">SkipRemainingHandlersException</a> section.
                    Here's an example :
 
                    <div>
                        <p>
                            <pre class="ace ace-java"
>public void myHandler(AppRequestContext context) {

    context.response().sendPlainText("I'm the last thing sent!");
    throw new SkipRemainingHandlersException();
}</pre> 
                        </p>
                    </div>

                </li>
                <li>
                    <a class="javadoc" href="/public/javadoc/org/spincast/core/exceptions/CustomStatusCodeException.html">CustomStatusCodeException</a> : 
                    This exception allows you to set an <code>HTTP status</code> to return. Then, your custom
                    Exception Route Handler can check this code and display something
                    accordingly. Also, in case you use the provided Exception Route Handler,
                    you still at least have control over the <code>HTTP status</code> sent to the user.
                    Here's an example : 
                    
                    <div>
                        <p>
                            <pre class="ace ace-java"
>public void myHandler(AppRequestContext context) {

    throw new CustomStatusCodeException("Forbidden!", HttpStatus.SC_FORBIDDEN);
}</pre> 
                        </p>
                    </div>
                </li>
                <li>
                <a class="javadoc" href="/public/javadoc/org/spincast/core/exceptions/PublicException.html">PublicException</a> : 
                    This exception allows you to 
                    specify a message that will be displayed to the user. This is
                    mainly useful if you use the <em>provided</em> Exception Route Handler because
                    in a <em>custom</em> handler you would have full control over what you send
                    as a response anyway... Here's an example : 

                    <div>
                        <p>
                            <pre class="ace ace-java"
>public void myHandler(AppRequestContext context) {

    throw new PublicException("You don't have the right to access this page",
                              HttpStatus.SC_FORBIDDEN);
}</pre> 
                        </p>
                    </div>
                </li>
            </ul>
        <p>   
    </div>
    
    {#==========================================
    Section "routing / Router is dynamic"
    ==========================================#}
    <div id="router_dynamic">
        <h4>
            <a class="anchor_small" href="#router_dynamic" title="permanent link"></a>
            The Router is dynamic
        </h4>
        <p>
            Note that the Spincast Router is <em>dynamic</em>, which means you can always add new Routes to it. This 
            also means you don't have to define all your Routes at the same place, you can let the
            controllers (or even the <code>plugins</code>) define their own Routes!
            
            <div>
                For example:
                <p>
                    <pre class="ace ace-java"
>public class UserControllerDefault implements UserController {

    @Inject
    protected void init(DefaultRouter router) {
        addRoutes(router);
    }

    protected void addRoutes(DefaultRouter router) {
        router.GET("/users/${userId}").save(this::getUser);
        router.POST("/users").save(this::addUser);
        router.DELETE("/users/${userId}").save(this::deleteUser);
    }

    @Override
    public void getUser(DefaultRequestContext context) {
        //...
    }

    @Override
    public void addUser(DefaultRequestContext context) {
        //...
    }

    @Override
    public void deleteUser(DefaultRequestContext context) {
        //...
    }
}</pre> 

                </p>
                <p>
                    <span class="explanation">Explanation :</span>
                    <ul>
                        <li>
                            <span class="code-line-nbr">3-6</span> : The Router is injected in an <a href="#init_method"><code>init()</code> method</a>.
                        </li>
                        <li>
                            <span class="code-line-nbr">8-12</span> : The controller adds its own Routes. Here, the 
                            <code>UserController</code> is responsible to add Routes related to <em>users</em>.
                        </li>   
                    </ul>
                </p>   
            </div>
        <p>
    </div>
    

</section>



            