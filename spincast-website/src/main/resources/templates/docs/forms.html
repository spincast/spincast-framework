{#==========================================
Docs : "Forms"
==========================================#}

<section id="forms">
    <h3>
        <a class="anchor" href="#forms" title="permanent link"></a>
        Forms
    </h3>
    <p>
        This section is about <em>HTML Forms</em>, as used on <a href="#quick_tutorial_traditional">traditional websites</a>.
        If you use a <a href="#quick_tutorial_spa">SPA</a> client-side, you in general don't use such
        POSTed forms, you rather use javascript to send and receive <code>Json</code> objects. 
        Both approaches are supported out of the box by Spincast but this specific section is about
        traditional <code>HTML</code> forms and their validation! 
    </p>
    <p>
        We're going to learn :

        <ul>
            <li>
                How to populate a form and bind its fields to an underlying <code>Form</code> object.
            </li>
            <li>
                How to validate a form that has been submitted.
            </li>
            <li>
                How to redisplay a validated form with resulting <code>validation messages</code>.
            </li>
        </ul>
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        A form always has a backing <code>model</code> to represent its data. This form
        model is sometimes called <em>"form backing object"</em>, <em>"form backing bean"</em>
        or <em>"command object"</em>. It's the object used to transfer the values
        of a form from the server to the client (to populate the form's fields) and vice versa. 
    </p>
    <p>
        On the server-side, this form model is represented using the 
        <a class="javadoc" href="/public/javadoc/org/spincast/core/request/Form.html">Form</a> class.
        A <code>Form</code> object is simply a <a href="#jsonobject">JsonObject</a>
        <em>with extra validation features</em>! You can manipulate a <code>Form</code> 
        object exactly as a <code>JsonObject</code> and even cast it as one.
    </p>
    
    <h4>
        <a class="anchor_small" href="#forms_validation_pattern" id="forms_validation_pattern" title="permanent link"></a>
        The validation pattern
    </h4>
    <p>
        The <em>validation pattern</em> shows how you create a form to 
        be displayed, validate the form when it is submitted, and 
        redisplay it again, with validation messages, if it is invalid...
    </p>
    <p>
        First, let's start with the <code>GET</code> handler, which is the one called to display a form
        for the first time :
        <p>      
            <div>
                <p>
                    <pre class="ace ace-java"
>

// GET handler
public void myHandlerGet(AppRequestContext context) {

    Form form = context.request().getForm("userForm");
    if (form == null) {
        form = context.request().getFormOrCreate("userForm");
        context.response().addForm(form);
        
        User user = getUser(...);
        form.set("name", user.getName());
    }
    
    context.response().sendTemplateHtml("/templates/userEdit.html");
}
</pre> 
                </p>
                <p>
                    <span class="explanation">Explanation :</span>
                    <ul>
                        <li>
                            <span class="code-line-nbr">5</span> : We check if the form already exist
                            in the response model. This may be the case if this <code>GET</code>
                            handler is called from an associated <code>POST</code> handler, because some validation
                            failed.
                        </li>
                        <li>
                            <span class="code-line-nbr">7</span> : If the form doesn't exist yet, we create
                            an new one.
                        </li>
                        <li>
                            <span class="code-line-nbr">8</span> : We add the form to the response model, so it
                            is available to the templating engine.
                        </li>
                        <li>
                            <span class="code-line-nbr">10-11</span> : We populate the form with the initial values,
                            if required.
                        </li>
                        <li>
                            <span class="code-line-nbr">14</span> : We send the response by evaluating a template which will
                            display the form.
                        </li>
                    </ul>
                </p>
            </div>
        </p>
    </p>
    <p>
        When the form is submitted, we retrieve its data inside a <code>POST</code> handler:
       <p>      
            <div>
                <p>
                    <pre class="ace ace-java"
>

// POST handler
public void myHandlerPost(AppRequestContext context) {

    Form form = context.request().getFormOrCreate("userForm");
    context.response().addForm(form);
    
    validateForm(form);
    
    if (!form.isValid()) {
        myHandlerGet(context);
        return;
    } else {

        processForm(form);
        
        context.response().redirect("/success",
                                    FlashMessageLevel.SUCCESS,
                                    "The user has been processed!");
    }
}
</pre> 
                </p>
                <p>
                    <span class="explanation">Explanation :</span>
                    <ul>
                        <li>
                            <span class="code-line-nbr">5</span> : We retrieve the posted form from the request.
                        </li>
                        <li>
                            <span class="code-line-nbr">6</span> : We immediately add the form to the response model.
                            This will make the form available to the templating engine but will also provide a
                            "validation" element containing any validation messages to display.
                        </li>
                        <li>
                            <span class="code-line-nbr">8</span> : We <a href="#forms_validation_intro">validate the form </a>and 
                            add error, warning or success validation messages to it.
                        </li>
                        <li>
                            <span class="code-line-nbr">10</span> : Once the validation is done, we check if the form is valid.
                        </li>
                        <li>
                            <span class="code-line-nbr">11-12</span> : if the form contains errors, we simply call the <code>GET</code>
                            handler so the form is displayed again, with the validation messages we added to it.
                        </li>
                        <li>
                            <span class="code-line-nbr">15</span> : if the form is valid, we process it. This may involve calling
                            services, editing entities, etc.
                        </li>
                        <li>
                            <span class="code-line-nbr">17-19</span> : we redirect the page with a <a href="#flash_messages">Flash message</a>
                            to indicate that the form was processed successfully!
                        </li>
                        
                        
                    </ul>
                </p>
            </div>
        </p>
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/tipy.png" />
        The important part to understand is how the <code>GET</code> handler first checks in the response model
        to see if the form already exists in it... Indeed, this handler may be called by the <code>POST</code> handler if
        a posted form is invalid... When it's the case, you do not want to populate the form with some default/initial
        values, you want to keep the submitted values!
    </p>
    <h4>
        <a class="anchor_small" href="#forms_displaying" id="forms_displaying" title="permanent link"></a>
        Displaying the Form
    </h4>
    <p>
        By using a dynamic <code>JsonObject</code>/<code>Form</code> object as the form model, a benefit is 
        that you don't have to create <em>in advance</em> all the elements required 
        to match the fields of the <code>HTML</code> form. Simply by using a valid
        <a href="#jsonobject_jsonpaths">JsonPath</a> as the <code>"name"</code> attribute of a
        field, the element will automatically be created on the form model.
    </p>
    <p>
        As an example, let's again use a form dedicated to editing a user. This form will
        display two fields : one for a <em>username</em> and one for an <em>email</em>. Our initial form
        model <em>doesn't have to specify those two elements</em> when it is first created :
        
        <div>
            <p>
                <pre class="ace ace-java"
>

// GET handler
public void myHandlerGet(AppRequestContext context) {

    Form userForm = context.request().getForm("userForm");
    if (userForm == null) {
    
        // Empty form! 
        // No username and no email elements are specified.
        userForm = context.request().getFormOrCreate("userForm");
        
        context.response().getModel().set("userForm", userForm);
    }
    
    context.response().sendTemplateHtml("/templates/userEdit.html");
}</pre> 
            </p>
        </div>
    </p>
    <p>
        Here's what the <code>HTML</code> for that form may look like (we are using the syntax for
        the default <code>Templating Engine</code>, <a href="http://www.mitchellbosecke.com/pebble/home">Pebble</a>):
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble"
>&lt;form method="post"&gt;
    &lt;div class="form-group"&gt;
        &lt;input type="text" 
               class="form-control" 
               name="userForm.username"
               value="{{userForm.username | default('')}}" /&gt;
    &lt;/div&gt;
    &lt;div class="form-group"&gt;
        &lt;input type="text" 
               class="form-control" 
               name="userForm.email"
               value="{{userForm.email | default('')}}" /&gt;
    &lt;/div&gt;
    &lt;input type="submit" /&gt;
&lt;/form&gt;</pre> 
            </p>
            {% endverbatim %}
            
            Notice that even if the form model doesn't contain any <code>"username"</code> or
            <code>"email"</code> elements, we still bind them to the HTML elements using their
            <code>JsonPaths</code> [<span class="code-line-nbr">6</span>] and here [<span class="code-line-nbr">12</span>].   
            This is possible in part because we use the <a href="http://www.mitchellbosecke.com/pebble/documentation/filter/default"><code>default('')</code></a> 
            filter : this filter tells Pebble to use an empty string if the element doesn't exist.
        </div>
    </p>
    <p>
        The <code>"name"</code> attributes of the HTML elements are very important : they represent 
        the <a href="#jsonobject_jsonpaths">JsonPaths</a> that Spincast is going to use to 
        dynamically create the Form object, when the page is submitted.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        So let's say this form is submitted. You would then access the values of the fields like so,
        in your <code>POST</code> handler:
        
        <div>
            <p>
                <pre class="ace ace-java"
>

// POST handler
public void myHandlerPost(AppRequestContext context) {

    Form userForm = context.request().getFormOrCreate("userForm");
    context.response().addForm(userForm);
    
    // The "username" and "email" elements have been
    // automatically created to represent the submitted
    // fields.
    String username = userForm.getString("username");
    String email = userForm.getString("email");  
    
    //...
}</pre> 
            </p>
        </div>
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/tipy.png" />
        As you can see, Spincast uses the <code>"name"</code> attribute
        of an HTML element as a <code>JsonPath</code> to dynamically create an 
        associated model element. 
        This gives you a lot of flexibility client-side
        since you can dynamically generate new fields or even <em>entire forms</em>, 
        using javascript.
    </p>
    
    <h4>
        <a class="anchor_small" href="#forms_display_field_text" id="forms_display_field_text" title="permanent link"></a>
        Text based fields
    </h4>
    <p>
        Text based fields, such as <code><em>text</em></code>, <code><em>password</em></code>, 
        <code><em>email</em></code> and <code><em>textarea</em></code> are
        very easy to manipulate :
        
        <ul>
            <li>
                You use the <code>JsonPath</code> you want for their associated model element as their
                <code>"name"</code> attribute.
            </li>
            <li>
                You use that same <code>JsonPath</code> to target 
                the <em>current value</em> of the element on the model, 
                and you output it in the <code>"value"</code> attribute.
            </li>
            <li>
                You use the <code>default('')</code> filter to make sure not exception
                is thrown if the model element doesn't exist yet.
            </li>
        </ul>
        
        Quick example :
        
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble"
>&lt;input type="text" 
       name="userForm.email"
       value="{{userForm.email | default('')}}" /&gt;</pre> 
            </p>
            {% endverbatim %}
        </div>
    </p>
    
    <h4>
        <a class="anchor_small" href="#forms_display_field_text_group" id="forms_display_field_text_group" title="permanent link"></a>
        Text based field <em>groups</em>
    </h4>
    <p>
        Sometimes we want multiple text fields <em>to be grouped together</em>. For example, let's say we
        want various <code>"tags"</code> to be associated with an <code>"articleForm"</code> object. Each of those
        <code>"tags"</code> will have its own dedicated field on the form, but we want all the <code>"tags"</code> to 
        be available <em>as a single array</em> when they are submitted. To achieve that :
        
        <ul>
            <li>
                We use the same <code>"name"</code> attribute for every field, but we suffix this name with the 
                position of the tag inside the final array.
                For example : <code>"articleForm.tags[0]"</code> or <code>"articleForm.tags[1]"</code> 
            </li>
            <li>
                We also use that same <code>"[X]"</code> suffixed name to get and display the <code>"value"</code> 
                attributes.  
            </li>
        </ul>
        What we are doing, again, is to use the <code><em>JsonPath</em></code> to target each element!
        For example :
        
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble" data-ace-hi="1,50,1,69|2,20,2,39|4,50,4,69|5,20,5,39|7,50,7,69|8,20,8,39"
>&lt;form method="post"&gt;
    &lt;input type="text" class="form-control" name="articleForm.tags[0]"
           value="{{articleForm.tags[0] | default('')}}" /&gt;
    
    &lt;input type="text" class="form-control" name="articleForm.tags[1]"
           value="{{articleForm.tags[1] | default('')}}"&gt;
    
    &lt;input type="text" class="form-control" name="articleForm.tags[2]"
           value="{{articleForm.tags[2] | default('')}}"&gt;
    &lt;input type="submit" /&gt;
&lt;/form&gt;</pre> 
            </p>
            {% endverbatim %}
        </div>
        
    </p>
    <p>
        When this form is submitted, you have access to the three <code>"tags"</code> as
        a single <code><em>JsonArray</em></code> :
        
        <div>
            <p>
                <pre class="ace ace-java"
>public void manageArticle(AppRequestContext context) {

    Form form = context.request().getFormOrCreate("articleForm");
    context.response().addForm(form);

    // Get all the tags of the article, as an array
    JsonArray tags = form.getJsonArray("tags");
    
    // You could also access one of the tag directly, using
    // its full JsonPath
    String thirdTag = form.getString("tags[2]");
    
    //...
}</pre> 
            </p>
        </div>
        
    </p>
    
    <h4>
        <a class="anchor_small" href="#forms_display_field_select" id="forms_display_field_select" title="permanent link"></a>
        Select fields
    </h4>
    <p>
        The <code>select</code> fields come in two flavors : single value or multiple values. To use them :
        
        <ul>
            <li>
                You specify the <code>JsonPath</code> of the associated element in the
                <code>"name"</code> attribute of the <code>select</code> HTML element.
            </li>
            <li>
                For every <code>option</code> elements of the field you
                use the <a href="#templating_filters_selected"><code>selected(...)</code></a> filter to check if the <code>option</code>
                should be selected or not.
            </li>
        </ul>
        
        Here's an example for a single value <code>select</code> field :
        
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble" data-ace-hi="1,14,1,31|3,27,3,69"
>

&lt;select name="userForm.favDrink" class="form-control"&gt;
    &lt;option value="tea" {{userForm.favDrink | selected("tea")}}&gt;Tea&lt;/option&gt;
    &lt;option value="coffee" {{userForm.favDrink | selected("coffee")}}&gt;Coffee&lt;/option&gt;
    &lt;option value="beer" {{userForm.favDrink | selected("beer")}}&gt;WBeer&lt;/option&gt;
&lt;/select&gt;</pre> 
            </p>
            {% endverbatim %}
        </div>
    </p>
    <p>
        In this example, the values of the <code>option</code> elements are <em>hardcoded</em>, they were
        known in advance : "tea", "coffee" and "beer". Here's a version where the <code>option</code> elements 
        are <em>dynamically generated</em> :

        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble"
>&lt;select name="userForm.favDrink" class="form-control"&gt;
    {% for drink in allDrinks %}
        &lt;option value="{{drink.id}}" {{userForm.favDrink | selected(drink.id)}}&gt;{{drink.name}}&lt;/option&gt;
    {% endfor %}
&lt;/select&gt;</pre> 
            </p>
            {% endverbatim %}
        </div>
    </p>
    <p>
        In this example, the <a href="#templating_filters_selected"><code>selected(...)</code></a> filter 
        compares the current favorite <code>drink</code>
        of the <code>user</code> (<code>"userForm.favDrink"</code>) to the value of every 
        <code>option</code> element and outputs the <code>"selected"</code>
        attribute if there is a match.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        To select a default option, you can specify <code>null</code> as one of its accepted values:
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble" data-ace-hi="3,59,3,75"
>

&lt;select name="userForm.favDrink" class="form-control"&gt;
    &lt;option value="tea" {{userForm.favDrink | selected("tea")}}&gt;Tea&lt;/option&gt;
    &lt;option value="coffee" {{userForm.favDrink | selected([null, "coffee"])}}&gt;Coffee&lt;/option&gt;
    &lt;option value="beer" {{userForm.favDrink | selected("beer")}}&gt;WBeer&lt;/option&gt;
&lt;/select&gt;</pre> 
            </p>
            {% endverbatim %}
        </div>
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        Displaying a <em>multiple values</em> <code>select</code> field is similar, but :
        
        <ul>
            <li>
                You use <code>"[]"</code> after the <code>"name"</code> attribute of the <code>select</code>
                field. This tells Spincast that an <em>array</em> of values is expected when the form
                is submitted.
            </li>
            <li>
                The left side of a <a href="#templating_filters_selected"><code>selected(...)</code></a>
                filter will be a <em>list</em> of values (since more than one option may have been
                selected). The filter will output the <code>"seleted"</code> attribute as long as the value 
                of an option matches <em>any of the values from the list</em>.
            </li>
        </ul>
        
        For example :
        
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble" data-ace-hi="1,8,1,16|1,23,1,43"
>

&lt;select multiple name="userForm.favDrinks[]" class="form-control"&gt;
    &lt;option value="tea" {{userForm.favDrinks | selected("tea")}}&gt;Tea&lt;/option&gt;
    &lt;option value="coffee" {{userForm.favDrinks | selected("coffee")}}&gt;Coffee&lt;/option&gt;
    &lt;option value="beer" {{userForm.favDrinks | selected("beer")}}&gt;WBeer&lt;/option&gt;
&lt;/select&gt;</pre> 
            </p>
            {% endverbatim %}
        </div>
    </p>

    <h4>
        <a class="anchor_small" href="#forms_display_field_radio" id="forms_display_field_radio" title="permanent link"></a>
        Radio Buttons
    </h4>
    <p>
        To display a radio buttons group :
        
        <ul>
            <li>
                You use the <code>JsonPath</code> of the associated model element as the
                <code>"name"</code> attributes.
            </li>
            <li>
                You output the <code>"value"</code> of each radio button. Those values can be
                hardcoded, or they can be dynamically generated inside a loop (we'll see an example 
                of both).
            </li>
            <li>
                You use the <a href="#templating_filters_checked"><code>checked(...)</code></a> 
                filter provided by Spincast determine if a radio button should be checked or
                not.
            </li>
        </ul>
    </p>
    <p>
        Let's first have a look at an example where the values of the radio buttons are <em>hardcoded</em> :
        
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble" data-ace-hi="6,22,6,25|13,22,13,28|20,22,20,26"
>&lt;div class="form-group"&gt;
    &lt;label for="drinkTea"&gt;
        &lt;input type="radio" 
               id="drinkTea" 
               name="userForm.favDrink"
               {{userForm.favDrink | checked("tea")}}
               value="tea"/&gt; Tea&lt;/label&gt;
    
    &lt;label for="drinkCoffee"&gt;
        &lt;input type="radio" 
               id="drinkCoffee" 
               name="userForm.favDrink"
               {{userForm.favDrink | checked("coffee")}}
               value="coffee"&gt; Coffee&lt;/label&gt;
    
    &lt;label for="drinkBeer"&gt;
        &lt;input type="radio" 
               id="drinkBeer" 
               name="userForm.favDrink"
               {{userForm.favDrink | checked("beer")}}
               value="beer"&gt; Beer&lt;/label&gt;
&lt;/div&gt;
</pre> 
            </p>
            {% endverbatim %}
        </div>
    </p>   
    <p>
        Let's focus on the <em>first</em> radio button of that group. First, 
        its <code>"name"</code> attribute :
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble" data-ace-hi="3,17,3,34"
>&lt;label for="drinkTea"&gt;
    &lt;input type="radio" 
           id="drinkTea" 
           name="userForm.favDrink"
           {{userForm.favDrink | checked("tea")}}
           value="tea"/&gt; Tea&lt;/label&gt;</pre> 
            </p>
            {% endverbatim %}
        </div>
        
        As we already said, the <code>"name"</code> attribute of a field is very important. Spincast uses it
        to create the element on the form model, when the form is submitted. This <code>"name"</code>
        will become the <a href="#jsonobject_jsonpaths">JsonPath</a> of the element on the form model.
        In our example, the form model would contain a <code>"favDrink"</code> element.
    </p>   
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        Let's now have a look at the <a href="#templating_filters_checked"><code>checked(...)</code></a> filter :
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble" data-ace-hi="4,11,4,49"
>&lt;label for="drinkTea"&gt;
    &lt;input type="radio" 
           id="drinkTea" 
           name="userForm.favDrink"
           {{userForm.favDrink | checked("tea")}}
           value="tea"/&gt; Tea&lt;/label&gt;</pre> 
            </p>
            {% endverbatim %}
        </div>
        <p>
            We don't know in advance if a radio button should be checked or not, this depends
            on the current value of the <code>"userForm.favDrink"</code> element. That's why we use
            <a href="#templating_filters_checked"><code>"checked(...)"</code></a>. This filter will compare the current
            value of the <code>"userForm.favDrink"</code> model element to the value
            of the radio button (<code>"tea"</code> in our example). If there is a match, a <code>"checked"</code>
            attribute is printed!
        </p>
    </p>   
    <p>
        <img src="/public/images/icons/tipy.png" />
        Note that the parameter of the <a href="#templating_filters_checked"><code>"checked(...)"</code></a> filter 
        can be an <em>array</em>. In that case, the
        filter will output <code>"checked"</code> if the current value 
        matches <em>any</em> of the elements. For example :
        
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble" data-ace-hi="4,41,4,66"
>&lt;label for="drinkTea"&gt;
    &lt;input type="radio" 
           id="drinkTea" 
           name="userForm.favDrink"
           {{userForm.favDrink | checked(["tea", "ice tea", chai"])}}
           value="tea"/&gt; Tea&lt;/label&gt;
</pre> 
            </p>
            {% endverbatim %}
        </div>
    </p>
    <p>
        This feature is mainly useful when the radio buttons are dynamically generated.
    </p>
    <p>
        <img src="/public/images/icons/tipy.png" />
        If you need a default radio button to be checked, without providing this information
        in the initial form model, you simply have to add "<code>null</code>" as an accepted
        element for the checkbox:
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble" data-ace-hi="4,41,4,54"
>&lt;label for="drinkTea"&gt;
    &lt;input type="radio" 
           id="drinkTea" 
           name="userForm.favDrink"
           {{userForm.favDrink | checked(["tea", null])}}
           value="tea"/&gt; Tea&lt;/label&gt;
</pre> 
            </p>
            {% endverbatim %}
        </div>
    </p> 
    
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        Speaking of dynamically generated radio buttons, let's see an example of those! The creation
        of the <em>response model</em>, in your <code>Route Handler</code>, may look like this :
        
        <div>
            <p>
                <pre class="ace ace-java"
>public void myRouteHandler(AppRequestContext context) {

    //==========================================
    // Creates the available drink options and add them
    // to the reponse model directly. 
    // There is no need to add them to the form 
    // itself (but you can!).
    //==========================================
    JsonArray allDrinks = context.json().createArray();
    context.response().getModel().set("allDrinks", allDrinks);

    JsonObject drink = context.json().create();
    drink.set("id", 1);
    drink.set("name", "Tea");
    allDrinks.add(drink);

    drink = context.json().create();
    drink.set("id", 2);
    drink.set("name", "Coffee");
    allDrinks.add(drink);

    drink = context.json().create();
    drink.set("id", 3);
    drink.set("name", "Beer");
    allDrinks.add(drink);

    //==========================================
    // Creates the form, if it doesn't already exist.
    //==========================================
    JsonObject form = context.response().getModel().getJsonObject("userForm");
    if (userForm == null) {
        form = context.json().create();
        context.response().getModel().set("userForm", form);
        
        // Specifies the initial favorite drink of the user.
        User user = getUser(...);
        JsonObject user = context.json().create();
        form.set("favDrink", user.getFavDrink());
    }

    context.response().sendTemplateHtml("/templates/userTemplate.html");
}</pre> 
            </p>
        </div>
    </p>
    <p>
        With this response model in place, we can dynamically generate the radio buttons
        group and check the current favorite one of the user :
    
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble" data-ace-hi="1,4,1,32|6,19,6,60|8,4,8,16"
>&lt;div class="form-group"&gt;
    {% for drink in allDrinks %}
        &lt;label for="drink_{{drink.id}}"&gt;
            &lt;input type="radio" 
                   id="drink_{{drink.id}}" 
                   name="userForm.favDrink"
                   {{userForm.favDrink | checked(drink.id)}}
                   value="{{drink.id}}"/&gt; {{drink.name}}&lt;/label&gt; 
    {% endfor %}
&lt;/div&gt;</pre> 
            </p>
            {% endverbatim %}
        </div>
    </p>
    
    <h4>
        <a class="anchor_small" href="#forms_display_field_checkboxes" id="forms_display_field_checkboxes" title="permanent link"></a>
        Checkboxes
    </h4>
    <p>
        Checkboxes are often used in one of those two situations :
        
        <ul>
            <li>
                To allow the user to select a <em>single</em> boolean value. For example :

                <div>
                    {% verbatim %}
                    <p>
                        <pre class="ace ace-pebble"
>[ ] Do you want to subscribe to our newsletter?</pre> 
                    </p>
                    {% endverbatim %}
                </div>  
            </li>
            <li>
                To allow the user to select <em>multiple</em> values for a single preference. For example :
                
                <div>
                    {% verbatim %}
                    <p>
                        <pre class="ace ace-pebble"
>Which drinks do you like?
[ ] Tea
[ ] Coffee
[ ] Beer</pre> 
                    </p>
                    {% endverbatim %}
                </div>  
            </li>
        </ul>
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        First, let's look at a single checkbox field :
        
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble" data-ace-hi="4,42,4,46|5,18,5,22"
>&lt;label for="tosAccepted"&gt;
    &lt;input type="checkbox" 
           id="tosAccepted" 
           name="myForm.tosAccepted"
           {{myForm.tosAccepted | checked(true)}}
           value="true" /&gt; I agree to the Terms of Service&lt;/label&gt;
</pre> 
            </p>
            {% endverbatim %}
        </div>
    </p>
    <p>
        <img src="/public/images/icons/tipy.png" />
        Note that, even if the value of the checkbox is <code>"true"</code> <em>as a string</em>,
        you can use <code>true</code> <em>as a boolean</em> as the filter parameter. 
        This is possible because the <a href="#templating_filters_checked"><code>checked(...)</code></a> 
        filter (and the <a href="#templating_filters_selected"><code>selected(...)</code></a> 
        filter) compares elements using 
        <a class="javadoc" href="/public/javadoc/org/spincast/core/utils/ObjectConverter.html#isEquivalent-java.lang.Object-java.lang.Object-"><em>equivalence</em></a>, 
        not <em>equality</em>. So <code>"true"</code>
        would match <code>true</code> and <code>"123.00"</code> would match <code>123</code>.
    </p>
    <p>
        When this field is submitted, you would be able to access 
        the boolean value associated with it using :
        
        <div>
            <p>
                <pre class="ace ace-java"
>public void myRouteHandler(AppRequestContext context) {

    Form form = context.request().getFormOrCreate("myForm");
    context.response().addForm(form);

    boolean tosAccepted = form.getBoolean("tosAccepted");
    
    //...
}</pre> 
            </p>
        </div>
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        Now, let's see an example of a <em>group</em> of checkboxes :
        
        <div>
            {% verbatim %}
            <p>
                <pre class="ace ace-pebble" data-ace-hi="4,21,4,42|11,21,11,42|18,21,18,42"
>&lt;div class="form-group"&gt;
    &lt;label for="drinkTea"&gt;
        &lt;input type="checkbox" 
               id="drinkTea" 
               name="userForm.favDrinks[0]"
               {{userForm.favDrinks[0] | checked("tea")}}
               value="tea"/&gt; Tea&lt;/label&gt;
    
    &lt;label for="drinkCoffee"&gt;
        &lt;input type="checkbox" 
               id="drinkCoffee" 
               name="userForm.favDrinks[1]"
               {{userForm.favDrinks[1] | checked("coffee")}}
               value="coffee"&gt; Coffee&lt;/label&gt;
    
    &lt;label for="drinkBeer"&gt;
        &lt;input type="checkbox" 
               id="drinkBeer" 
               name="userForm.favDrinks[2]"
               {{userForm.favDrinks[2] | checked("beer")}}
               value="beer"&gt; Beer&lt;/label&gt;
&lt;/div&gt;</pre> 
            </p>
            {% endverbatim %}
        </div>

        Here, the checkboxes are grouped together since they share the same <code>"name"</code>
        attribute, name that is suffixed with the position of the element in the group.
        Again, their <code>"name"</code> is the <a href="#jsonobject_jsonpaths">JsonPath</a>
        of their associated element on the form model.
    </p>
    <p>
        With this in place, we can access all the checked <code>"favorite drinks"</code> as a single array,
        in our handler. 
    </p>
    <p>
        In the following example, we will retrieve such array without 
        using a proper <code>Form</code> object, but by using <code>request.getFormData()</code> directly, 
        to show this is also an option! But note that if you do it that way, you won't have access to the
        built-in validation features a <code>Form</code> provide... You are manipulating the
        form data as a raw <code>JsonObject</code>! :
        
        <div>
            <p>
                <pre class="ace ace-java"
>public void myRouteHandler(AppRequestContext context) {

    JsonObject model = context.request().getFormData();
    
    // The checked favorite drinks, as an array!
    JsonArray favDrinks = model.getJsonArray("userForm.favDrinks");
    
    //...
}</pre> 
            </p>
        </div> 
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/tipy.png" />
        Finally, note that the <em>positions</em> used in the <code>"name"</code> HTML attributes
        are kept when we receive the array! This means that if the
        user only checked <code>"beer"</code> for example (the last option), the array 
        received in our handler will be <code>[null, null, "beer"]</code>, not <code>["beer"]</code>! 
        This is a good thing because the
        <code>JsonPath</code> we use for an element always stays valid (<code>"userForm.favDrinks[2]"</code>
        here).
    </p>
    
    <h4>
        <a class="anchor_small" href="#forms_display_file_upload" id="forms_display_file_upload" title="permanent link"></a>
        File upload
    </h4>
    <p>
        Uploading a file is very easy using Spincast. The main difference between a <code>"file"</code> element
        and the other types of elements is that the uploaded file
        will not be available as a <em>form data</em> when submitted. You'll have to use a dedicated method to 
        retrieve it. 
    </p>
    <p>
        The <code>HTML</code> part is very standard :
        
        <div>
            <p>
                <pre class="ace ace-pebble" data-ace-hi="1,11,1,22|1,50,1,62"
>&lt;form action="/upload" method="post" enctype="multipart/form-data"&gt;
    &lt;input type="file" class="form-control" name="fileToUpload"&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;</pre> 
            </p>
        </div>
    </p>
    <p>
        To retrieve the uploaded file, you use one of the <code>getUploadedFileXXX(...)</code>
        methods on the <code>request()</code> add-on. For example :
        
        <div>
            <p>
                <pre class="ace ace-java" data-ace-hi="2,41,2,78"
>public void myRouteHandler(AppRequestContext context) {

    File uploadedFile = context.request().getUploadedFileFirst("fileToUpload");
}</pre> 
            </p>
        </div>
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/tipy.png" />
        Note that even if the uploaded file is not part of the <code>form data</code>, you can still 
        perform validation</a>, as we'll see in the next section.
    </p>

    <h4>
        <a class="anchor_small" href="#forms_validation_intro" id="forms_validation_intro" title="permanent link"></a>
        Form validation introduction
    </h4>
    <p>
        Validating a submitted form involves three main steps :
        
        <ul>
            <li>
                Retrieving the submitted form data.
            </li>
            <li>
                Validating the form, and adding resulting <code>validation messages</code> to it.
            </li>
            <li>
                Redisplaying the form with the <code>validation messages</code> resulting 
                from the validation. 
                If the form is <em>valid</em>, you may instead want to redirect the user to 
                a confirmation page where a success <a href="#flash_messages">Flash Message</a> will be
                displayed.
            </li>
        </ul>
    </p>
    
    <h4>
        <a class="anchor_small" href="#forms_validation_data" id="forms_validation_data" title="permanent link"></a>
        Retrieving the submitted form
    </h4>
    <p>
        When an <code>HTML</code> form is submitted, Spincast treats the
        <code>"name"</code> attributes of the fields as <a href="#jsonobject_jsonpaths">JsonPaths</a> in order to create 
        a <a class="javadoc" href="/public/javadoc/org/spincast/core/request/Form.html">Form</a> (a plain <a href="#jsonobject">JsonObject</a>
        with extra validation features)
        representing the <code>form model</code>. In other words,
        Spincast converts the submitted data to a <code>Form</code> instance so you can easily validate and manipulate it.
    </p>
    <p>
        You access that <code>Form</code> representing the submitted data by using the
        <code>getFormOrCreate(...)</code> method of the <code>request()</code> add-on:
        
        <div>
            <p>
                <pre class="ace ace-java" data-ace-hi="4,38,4,65"
>

// POST handler
public void myHandlerPost(AppRequestContext context) {

    Form userForm = context.request().getFormOrCreate("userForm");
    context.response().addForm(userForm);
    
    //...
}</pre> 
            </p>
        </div>
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        If you have more than one form on the same <code>HTML</code> page, you simply give them different names, and check
        which one has been submitted, by looking for the presence of a field which should always be submitted:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java"
>

// POST handler
public void myHandlerPost(AppRequestContext context) {

    Form userForm = context.request().getFormOrCreate("userForm");
    if(userForm.getString("userFormBtn") != null) {
        context.response().addForm(userForm);
        processUserForm(context, userForm);
        return;
    }
    
    Form bookForm = context.request().getFormOrCreate("bookForm");
    if(bookForm.getString("bookFormBtn") != null) {
        context.response().addForm(bookForm);
        processBookForm(context, bookForm);
        return;
    }
    
    //...
}</pre> 
            </p>
        </div>
    </p>
    
    <h4>
        <a class="anchor_small" href="#forms_validation_validating" id="forms_validation_validating" title="permanent link"></a>
        Performing validations
    </h4>
    <p>
        Once you have the <code>Form</code> representing the submitted data, you can start validating it.
        Forms implement the <a class="javadoc" href="/public/javadoc/org/spincast/core/validation/ValidationSet.html">ValidationSet</a>
        interface and allow you to store validation results directly in them.
    </p>
    <p>
        Here's an example where we validate that a submitted "<em>email</em>" is valid, and add an error to the form if
        it's not: 
        
        <div>
            <p>
                <pre class="ace ace-java"
>

// POST handler
public void myHandlerPost(AppRequestContext context) {

    Form form = context.request().getFormOrCreate("userForm");
    context.response().addForm(form);
    
    String email = form.getString("email");
    
    if (!form.validators().isEmailValid(email)) {
        form.addError("email",
                      "email_invalid",
                      "The email is invalid");
    }
    
    //... 
}</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">5</span> : We retrieve the submitted
                        form from the request.
                    </li>
                    <li>
                        <span class="code-line-nbr">6</span> : We immediately add the
                        form back to the response model.
                    </li>
                    <li>
                        <span class="code-line-nbr">8</span> : We get the "email" from
                        the form.
                    </li>
                    <li>
                        <span class="code-line-nbr">10</span> : We validate the email using
                        a validator provided on the Form object itself! 
                    </li>
                    <li>
                        <span class="code-line-nbr">11-13</span> : If the email is invalid,
                        we add an <em>error</em> validation message to the form.
                    </li>
                    <li>
                        <span class="code-line-nbr">11</span> : The first parameter, "email" is the
                        <a href="#jsonobject_jsonpaths">JsonPath</a> of the validated element.
                    </li>
                    <li>
                        <span class="code-line-nbr">12</span> : The second parameter, "email_invalid" is a
                        code representing the error. This can be used client-side to know what 
                        exact error occured.
                    </li>
                    <li>
                        <span class="code-line-nbr">13</span> : The third parameter is the message
                        to display to the user.
                    </li>
                    
                </ul>
            </p>
        </div>
    </p> 
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        To validate an element of the form, you can use any method you need. Some validators,
        such as <code>isEmailValid(...)</code> are provided by the 
        <a class="javadoc" href="/public/javadoc/org/spincast/core/request/Form.html#validators--">form.validators()</a>
        method. But, most of the time, you're going to use custom code for your validations. For example:  
        
        <div>
            <p>
                <pre class="ace ace-java" data-ace-hi="4,0,4,29"
>

Form form = context.request().getFormOrCreate("userForm");

String name = form.getString("name");
if(StringUtils.isBlank(name)) {
    form.addError("name",
                  "name_empty",
                  "The name is required!");
}</pre> 
            </p>
        </div>
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        Finally, note that there are <code>"success"</code> and <code>"warning"</code>
        validation messages too, in addition to the <code>"error"</code> ones.
    </p>
    
    <h4>
        <a class="anchor_small" href="#forms_validation_messages" id="forms_validation_messages" title="permanent link"></a>
        Displaying Validation Messages
    </h4>
    <p>
    
        When you add the form to the response model, using <code>context.response().addForm(form)</code>,
        you are in fact adding <em>two</em> elements :
        <ul>
            <li>
                The form itself, using its name as the key in the response model.
            </li>
            <li>
                A <code>Validation</code> element, containing the validation messages added on the form.
            </li> 
        </ul>
    </p>
    <p>   
        
        By default, the <code>Validation</code> element containing the messages of a validated form is called
        "<code>validation</code>". You can choose a different name for this element when adding 
        the form to the response model. For example:
        
        <div>
            <p>
                <pre class="ace ace-java" data-ace-hi="8,41,8,61"
>

// POST handler
public void myHandlerPost(AppRequestContext context) {

    Form userForm = context.request().getFormOrCreate("userForm");
    
    // Uses "userFormValidation" as the name for the
    // validation element.
    context.response().addForm(userForm, "userFormValidation");
    
    // validation...
}</pre> 
            </p>
        </div>
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        When it reaches the templating engine, the <code>Validation</code> element associated 
        with a form will contain:
        <ul>
            <li>
                An object for every validation message added to the form, with the
                <a href="#jsonobject_jsonpaths">JsonPath</a> of the validated element as the key and three fields, "<em>level</em>", 
                "<em>code</em>" and "<em>text</em>":
                
                <div>
                    <p>
                        <pre class="ace ace-json"
>"userForm.name" : {
    "level" : "ERROR",
    "code" : "name_empty",
    "text" : "The name is required!" 
}</pre> 
                    </p> 
                </div> 
            </li>
            <li>
                A special "<code>_</code>" element that summarizes all the validations
                performed on the form:
                
                <div>
                    <p>
                        <pre class="ace ace-json"
>"userForm._" : {
    "hasErrors" : true,
    "hasWarnings" : false,
    "isValid" : false,
    "hasSuccesses" : false
}</pre> 
                    </p> 
                </div> 
                <img class="inlineIcon" src="/public/images/icons/tipy.png" />
                This "<code>_</code>" element can be used in a template to display something if the
                form contains errors, for example.
            </li>
            
        </ul>
        
    
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        Here's a bigger chunk of the model the templating engine will have access to
        to redisplay an invalid form :
        <div>
            <p>
                <pre class="ace ace-json"
>{
    // The form itself
    "userForm" : {
        "name" : ""
        "email" : "abc"
        "books": [
            {
                "title" : "Dune",
                "author": "Frank Herbert"
            },
            {
                "title" : "The Hitchhiker's Guide to the Galaxy",
                "author" : ""
            }
        ]
    },
    
    // The "validation" element
    "validation" : {
        "userForm._" : {
            "hasErrors" : true,
            "hasWarnings" : false,
            "isValid" : false,
            "hasSuccesses" : false
        },
        "userForm.name" : {
            "level" : "ERROR",
            "code" : "name_empty",
            "text" : "The name is required!" 
        },
        "userForm.email" : {
            "level" : "ERROR",
            "code" : "email_invalid",
            "text" : "The email is invalid" 
        },
        "userForm.books[1].author" : {
            "level" : "ERROR",
            "code" : "author_empty",
            "text" : "The author is required!" 
        }
    }
    
    // ...
}</pre> 
            </p> 
        </div> 
    </p> 
    <p> 
        The important things to notice are :
        <ul>
            <li>
                In the form object, each element is positioned at its <a href="#jsonobject_jsonpaths">JsonPath</a>. For example,
                the author of the second book is located at <code>userForm.books[1].author</code>.
            </li>
            <li>
                In the "<em>validation</em>" element, each keys is the <em>string representation</em> of
                the JsonPath of the validated element! For example : <code>validation[<em>'userForm.books[1].author'</em>]</code>.
            </li>  
        </ul>
        It is easy to find the validation messages associated with a specific element since the JsonPath
        of that element will be the key to use to retrieve them. For example:
        
        {% verbatim %}
        <p>
            <pre class="ace ace-pebble" data-ace-hi="3,17,3,31|5,4,5,59"
>&lt;div class="form-group"&gt;
    &lt;input type="text" 
           class="form-control" 
           name="userForm.email"
           value="{{userForm.email | default('')}}" /&gt;
    {{validation['userForm.email'] | validationMessages()}}
&lt;/div&gt;</pre> 
        </p>
        {% endverbatim %}
    </p> 
    <p> 
        <img class="inlineIcon" src="/public/images/icons/tipy.png" />
        Note that when you add a validation message, you can specify some options on how to
        render the message. You do this by passing a 
        <a class="javadoc" href="/public/javadoc/org/spincast/core/validation/ValidationHtmlEscapeType.html">ValidationHtmlEscapeType</a> 
        parameter:
        
        <div>
            <p>
                <pre class="ace ace-java" data-ace-hi="4,14,4,48"
>

form.addError("email",
              "email_invalid",
              "Invalid email: &lt;em&gt;" + email + "&lt;/em&gt;",
              ValidationHtmlEscapeType.NO_ESCAPE);
</pre> 
            </p>
        </div>
    </p> 
    <p> 
        The possible values of <code>ValidationHtmlEscapeType</code> are:
        <ul>
            <li>
                <code>ESCAPE</code>: escapes the message to display. This is the default value.
            </li>
            <li>
                <code>NO_ESCAPE</code>: does not escape the message to display. Any HTML will be rendered.
            </li>
            <li>
                <code>PRE</code>: displays the message inside "<code>&lt;pre&gt;&lt;/pre&gt;</code>" tags.
            </li>
        </ul>
    <p>
    

    <h5>
        <a class="anchor_small" href="#forms_validation_filters" id="forms_validation_filters" title="permanent link"></a>
        Validation Filters
    </h5>
    <p>
        Spincast provides utilities to display the validation messages with the default <code>Templating Engine</code>,
        <a href="http://www.mitchellbosecke.com/pebble/home">Pebble</a>. But, as we saw, the template model is a 
        simple <code>Map&lt;String, Object&gt;</code> so no magic is involved and any other <code>Templating Engine</code> 
        can be used.
    </p>
    <p>  
        <img class="inlineIcon" src="/public/images/icons/tipy.png" />
        Have a look at the <a href="/demos-tutorials/html-forms/single-field">Forms + Validation demos</a>
        section to see the following validation filters in action!
    </p>
    <p>
        <ul class="apiList">
            <li>
                <code class="apiItem"><em>ValidationMessages</em> | <span>validationMessages</span>()</code>
                <div class="well">
                     <p>
                         This filter uses a <code>HTML</code> template fragment to output the <code>Validation Messages</code> associated with an element.
                     </p>
                     <p>
                         Here's an example :
                         
                        <div>
                            {% verbatim %}
                            <p>
                                <pre class="ace ace-pebble" data-ace-hi="5,4,5,57"
>&lt;div class="form-group"&gt;
    &lt;input type="text" 
           class="form-control" 
           name="myForm.email"
           value="{{myForm.email | default('')}}" /&gt;
    {{validation['myForm.email'] | validationMessages()}}
&lt;/div&gt;</pre> 
                            </p>
                            {% endverbatim %}
                        </div>
                     </p>
                     <p>
                         The path to the template fragment is configurable using the 
                         <a class="javadoc" href="/public/javadoc/org/spincast/plugins/pebble/SpincastPebbleTemplatingEngineConfig.html#getValidationMessagesTemplatePath--">SpincastPebbleTemplatingEngineConfig#getValidationMessagesTemplatePath()</a> 
                         method. The default path is <code>"/spincast/spincast-plugins-pebble/spincastPebbleExtension/validationMessagesTemplate.html"</code> which points
                         to a template fragment provided by Spincast.
                     </p>
                </div>
            </li>
            
            <li>
                <code class="apiItem"><em>ValidationMessages</em> | <span>validationGroupMessages</span>()</code>
                <div class="well">
                     <p>
                         This filter is similar to <code>validationMessages()</code> but uses a different template fragment.
                         Its purpose is to output the <code>Validation Messages</code> of a <em>group of elements</em>.
                     </p>
                     <p>
                         Here's an example :
                         
                        <div>
                            {% verbatim %}
                            <p>
                                <pre class="ace ace-pebble" data-ace-hi="4,8,4,67"
>&lt;div id="tagsGroup" class="form-group {{validation['demoForm.tags'] | validationClass()}}"&gt;

    &lt;div class="col-sm-4"&gt;
        &lt;label class="control-label"&gt;Tags *&lt;/label&gt;
        {{validation['demoForm.tags'] | validationGroupMessages()}}
    &lt;/div&gt;
    
    &lt;div class="col-sm-8"&gt;
        &lt;input type="text" name="demoForm.tags[0]" 
               class="form-control {{validation['demoForm.tags[0]'] | validationClass()}}"
               value="{{demoForm.tags[0] | default('')}}" /&gt;
        {{validation['demoForm.tags[0]'] | validationMessages()}}
        
        &lt;input type="text" name="demoForm.tags[1]" 
               class="form-control {{validation['demoForm.tags[1]'] | validationClass()}}"
               value="{{demoForm.tags[1] | default('')}}"&gt;
        {{validation['demoForm.tags[1]'] | validationMessages()}}
    &lt;/div&gt;
&lt;/div&gt;</pre> 
                            </p>
                            {% endverbatim %}
                        </div>
                     </p>
                     <p>
                         In this example, we ask the user to enter two tags. If one is invalid, we may want to display
                         a <code>"This tag is invalid"</code> message below the invalid field, but we may also want to
                         display a <em>global</em> <code>"At least one tag is invalid"</code> below the group title, <code>"Tags *"</code>.
                     </p>
                     <p>
                        This is exactly what the  <code>validationGroupMessages()</code> filter is for. 
                        As you may notice, <code>"demoForm.tags"</code> is, in fact, the <code>JsonPath</code> to the
                        <em>tags array itself</em>.
                     </p>
                     <p>
                         The path to the template fragment used by this filter is
                         configurable using the <a class="javadoc" href="/public/javadoc/org/spincast/plugins/pebble/SpincastPebbleTemplatingEngineConfig.html#getValidationGroupMessagesTemplatePath--">SpincastPebbleTemplatingEngineConfig#getValidationGroupMessagesTemplatePath()</a> 
                         method. The default path is <code>"/spincast/spincast-plugins-pebble/spincastPebbleExtension/validationGroupMessagesTemplate.html"</code> which is
                         a template fragment provided by Spincast.
                     </p>
                </div>
            </li>
            <li>
                <code class="apiItem"><em>ValidationMessages</em> | <span>validationClass</span>()</code>
                <div class="well">
                     <p>
                         The <code>validationClass(...)</code> filter checks if there are 
                         <code>Validation Messages</code> and, if so, it outputs a <em>class name</em>.
                     </p>
                     <p>
                         The default <em>class names</em> are :
                         
                         <ul>
                            <li>
                                <code><strong>"has-error"</strong></code> : when there is at least one <code><em>Error</em> Validation Message</code>.
                            </li>
                            <li>
                                <code><strong>"has-warning"</strong></code> : when there is at least one <code><em>Warning</em> Validation Message</code>.
                            </li>
                            <li>
                                <code><strong>"has-success"</strong></code> : when there is at least one <code><em>Success</em> Validation Message</code>.
                            </li>
                            <li>
                                <code><strong>"has-no-message"</strong></code> : when there are no <code>Validation Messages</code> at all.
                            </li>
                         </ul>
                     </p>
                     <p>
                         For example :
                         
                         <div>
                            {% verbatim %}
                            <p>
                                <pre class="ace ace-pebble" data-ace-hi="1,39,1,89|10,35,10,89|15,35,15,89"
>

&lt;div id="tagsGroup" class="form-group {{validation['demoForm.tags'] | validationClass()}}"&gt;

    &lt;div class="col-sm-4"&gt;
        &lt;label class="control-label"&gt;Tags *&lt;/label&gt;
        {{validation['demoForm.tags'] | validationGroupMessages()}}
    &lt;/div&gt;
    
    &lt;div class="col-sm-8"&gt;
        &lt;input type="text" name="demoForm.tags[0]" 
               class="form-control {{validation['demoForm.tags[0]'] | validationClass()}}"
               value="{{demoForm.tags[0] | default('')}}" /&gt;
        {{validation['demoForm.tags[0]'] | validationMessages()}}
        
        &lt;input type="text" name="demoForm.tags[1]" 
               class="form-control {{validation['demoForm.tags[1]'] | validationClass()}}"
               value="{{demoForm.tags[1] | default('')}}"&gt;
        {{validation['demoForm.tags[1]'] | validationMessages()}}
    &lt;/div&gt;
&lt;/div&gt;</pre> 
                            </p>
                            {% endverbatim %}
                         </div>
                     </p>
                     
                     The <code>validationClass()</code> filter can be used both on single fields and
                     on a <em>group of fields</em>. It is up to you to tweak the <code>CSS</code> of your application
                     so the generated class are used properly.
                 </div>
            </li>
            <li>
                <code class="apiItem"><em>ValidationMessages</em> | <span>validationFresh</span>()</code><br />
                <code class="apiItem"><em>ValidationMessages</em> | <span>validationSubmitted</span>()</code>
                <div class="well">
                     <p>
                         Those two filters are used to determine if a form is displayed for the first time,
                         or if it has been submitted and is currently redisplayed with 
                         potential <code>Validation Messages</code>. When one of those filters returns <code>true</code>,
                         the other necessarily returns <code>false</code>.
                     </p>
                     <p>
                         Most of the time, you are going to use the special 
                         <code>"_"</code> element, representing the validation as a whole, as the element 
                         passed to those filters.
                         For example :
                         
                         <div>
                            {% verbatim %}
                            <p>
                                <pre class="ace ace-pebble" data-ace-hi="1,1,1,52|3,1,3,12"
>

 {% if validation['myForm._'] | validationFresh() %}
     &lt;div&gt;This form is displayed for the first time!&lt;/div&gt; 
 {% endif %}
</pre> 
                            </p>
                            {% endverbatim %}
                         </div>  
                         and :
                         <div>
                            {% verbatim %}
                            <p>
                                <pre class="ace ace-pebble" data-ace-hi="1,1,1,56|3,1,3,12"
>

 {% if validation['myForm._'] | validationSubmitted() %}
     &lt;div&gt;This form has been validated!&lt;/div&gt; 
 {% endif %}
</pre> 
                            </p>
                            {% endverbatim %}
                         </div>  
                     </p>
                 </div>
            </li> 
            <li>
                <code class="apiItem"><em>ValidationMessages</em> | <span>validationHasErrors</span>()</code><br />
                <code class="apiItem"><em>ValidationMessages</em> | <span>validationHasWarnings</span>()</code><br />
                <code class="apiItem"><em>ValidationMessages</em> | <span>validationHasSuccesses</span>()</code><br />
                <code class="apiItem"><em>ValidationMessages</em> | <span>validationIsValid</span>()</code>
                <div class="well">
                     <p>
                         Those four filters check if there are <code>Validation Messages</code> of a
                         particular level and return <code>true</code> or <code>false</code>.
                    </p>
                     <p>
                         For example, you could use those filters to determine if you have to display an element 
                         or not, depending of the result of a validation.
                     </p>
                     <p>
                         <ul>
                            <li>
                                <code><strong>validationHasErrors()</strong></code> : returns <code>true</code> if there is at least
                                one <code><em>Error</em> Validation Message</code>.
                            </li>
                            <li>
                                <code><strong>validationHasWarnings()</strong></code> : returns <code>true</code> if there is at least
                                one <code><em>Warning</em> Validation Message</code>.
                            </li>
                            <li>
                                <code><strong>validationHasSuccesses()</strong></code> :returns <code>true</code> if there is at least
                                one <code><em>Success</em> Validation Message</code>.
                            </li>
                            <li>
                                <code><strong>validationIsValid()</strong></code> : returns<code>true</code> if there is 
                                no <code>Validation Message</code> at all.
                            </li> 
                         </ul>

                         For example :
                         <div>
                            {% verbatim %}
                            <p>
                                <pre class="ace ace-pebble" data-ace-hi="1,1,1,60|3,1,3,12"
>

 {% if validation['myForm.email'] | validationHasErrors() %}
     &lt;div&gt;There are errors associated with the email field.&lt;/div&gt; 
 {% endif %}
</pre> 
                            </p>
                            {% endverbatim %}
                         </div>
                     </p>
                     <p>
                         <br />
                         <img class="inlineIcon" src="/public/images/icons/tipy.png" />
                         An important thing to know is that you can also use those filters to see if the
                         form itself, as a whole, contains <code>Validation Messages</code>
                         at a specific level. To do that, you use the special <code>"_"</code> element representing
                         the form itself. For example :
                         
                         <div>
                            {% verbatim %}
                            <p>
                                <pre class="ace ace-pebble" data-ace-hi="1,1,1,56|3,1,3,12"
>

 {% if validation['myForm._'] | validationHasErrors() %}
     &lt;div&gt;The form contains errors!&lt;/div&gt; 
 {% endif %}
</pre> 
                            </p>
                            {% endverbatim %}
                         </div>
                     </p>
                     <p>
                         <br />
                         <img class="inlineIcon" src="/public/images/icons/tipy.png" />
                         It is also important to know that those filters will often be used
                         in association with the <code><em>validationSubmitted(...)</em></code> filter. 
                         The reason is that when a form is displayed
                         for the first time, it doesn't contain any <code>Validation Messages</code>, so
                         the <code>validationIsValid(...)</code> filter will return <code>true</code>. 
                     </p>
                     <p>
                        But if you want to know if the form is valid <em>after having been validated</em>,
                        then you need to use the <code>validationSubmitted(...)</code> filter too :

                        <div>
                            {% verbatim %}
                            <p>
                                <pre class="ace ace-pebble" data-ace-hi="1,1,1,109|3,1,3,12"
>

 {% if validation['myForm._'] | validationSubmitted() and validation['myForm.email'] | validationIsValid() %}
     &lt;div&gt;The email has been validated and is ok!&lt;/div&gt; 
 {% endif %}
</pre> 
                            </p>
                            {% endverbatim %}
                         </div>
                     </p>
                 </div>
            </li>
        </ul>
    </p>

    <h4>
        <a class="anchor_small" href="#forms_generic" id="forms_generic" title="permanent link"></a>
        Forms are generic
    </h4>
    
    <p>
        You may have noticed that we are not using a <em>dedicated class</em> to represent the form 
        model (a <code>"UserForm"</code> class, for example) : we use plain <code>JsonObject</code> objects
        (which <code>Form</code> object are based on).
    </p>
    <p>
        Here's why:
        <ul>
            <li>
                <p>
                    You may be thinking about reusing an existing <em>Entity</em> class for the model of your form. 
                    For example, you may want to use an existing <code>"User"</code> Entity class for the model of a form
                    dedicated to the creation of a new user. This seems logical at first since a lot
                    of fields on the form would have a matching field on that <code>User</code> Entity class...
                    But, in  practice, it's very rare that an existing <em>Entity</em> class contains <em>all</em> the fields
                    required to model the form.
                </p>
                <p>
                    Let's say our form has a <code>"name"</code> field and a <code>"email"</code> field and uses those to create
                    a new user : those fields would probably indeed have matching fields on a <code>"User"</code> Entity. 
                    But what about a <em>captcha</em>? Or an option to <em>"subscribe to our newsletter"</em>? Those two 
                    fields on the form have nothing to do with a <code>"user"</code>
                    and there won't be matching fields for them on a <code>"User"</code> Entity class...
                    So, what you do then? You have to create a new class that contains <em>all</em> the required
                    fields. For that, you may be tempted to <em>extend</em> the <code>"User"</code> Entity and simply add 
                    the missing fields, but our opinion is that this is hackish at best and clearly not a good
                    practice.
                </p>
            </li>
            <li>
                <p>
                    You may also feel that using a dedicated class for such form model is more robust, since that model
                    is then <em>typed</em>. We understand this feeling since we're huge fans of statically typed code! But, 
                    <em>for this particular component</em>, for the model of a form, our opinion is that a 
                    dedicated class is not very beneficial...
                </p>
                <p>
                    As soon as your form model leaves your controller, it
                    is pretty much converted to a simple and dumb <code>Map&lt;String, Object&gt;</code>, so the <code>Templating Engine</code>
                    can use it easily. At that moment, your typed form model is no more!
                    And, at the end of the day, the model becomes plain <code>HTML</code> fields : nothing
                    is typed there either.
                </p>
                <p>
                    In other words, if you use a dedicated class for your form model, this model is going to be
                    typed for a very short period, and we feel this doesn't worth the effort. That said, when your form
                    has been validated and everything is fine, <em>then</em> you may want to convert the
                    <code>JsonObject</code>/<code>Form</code> object to a dedicated <code>Entity</code> class and pass it to 
                    services, repositories, etc.
                </p>
            </li>
            <li>
                Last but not least : using an existing <code>Entity</code> class as a form model can lead to
                <a href="/public/varia/ounce_springframework_vulnerabilities.pdf" target="_blank">security vulnerabilities</a> (<code>PDF</code>)
                if you are not careful.
            </li>
        </ul>
    </p>
    <p> 
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        In case you still want to use a dedicated class to back your forms, you are free to do so,
        and here's a quick example.... First, you would create a dedicated class for the model :
        
        <div>
            <p>
                <pre class="ace ace-java"
>public class UserCreationForm {
    
    private String username;
    private String email;
    private String captcha;
    
    //... Getters
    //... Setters
}</pre> 
            </p>
        </div>
        
        You would then create a model instance like so :
     
        <div>
            <p>
                <pre class="ace ace-java"
>public void displayUserForm(AppRequestContext context) {

    // A typed form model
    UserCreationForm userForm = new UserCreationForm();
    
    // ... that is quickly converted to a 
    // JsonObject anyway when added to the response model!
    context.response().getModel().set("userForm", userForm);
    
    sendMyTemplate();
}</pre> 
            </p>
        </div>
    </p>
    <p> 
        When the form is submitted, you would then convert the <code>form</code>,
        which is a <code>JsonObject</code> under the hood, to an instance of your 
        <code>UserCreationForm</code> class :
        <div>
            <p>
                <pre class="ace ace-java" data-ace-hi="5,39,5,71"
>public void manageUserForm(AppRequestContext context) {

    // Back to a typed version of the form model!
    UserCreationForm userForm = context.request()
                                       .getFormOrCreate("userForm")
                                       .convert(UserCreationForm.class);
                                       
   // ...
}</pre> 
            </p>
        </div>
    </p>
    

</section>




            