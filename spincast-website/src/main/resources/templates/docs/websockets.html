{#==========================================
Docs : "WebSockets"
==========================================#}

<section id="websockets">
    <h3>
        <a class="anchor" href="#websockets" title="permanent link"></a>
        WebSockets
    </h3>
    
    <p>
        <a href="https://en.wikipedia.org/wiki/WebSocket">WebSockets</a> allow you to
        establish a <em>permanent</em> connection between your application and your users. Doing so,
        you can receive messages from them, but you can also <em>send</em> messages to 
        them, at any time. This is very different than standard <code>HTTP</code> which 
        is: <em>one request by the user</em> => <em>one response by the application</em>.
    </p>
    <p>
        WebSockets are mostly used when...
        
        <ul>
            <li>
                You want your application to be able to <em>push</em> messages to the connected 
                users, without waiting for them to make requests.
            </li>
            <li>
                You need your application to be the central point where multiple users can share real-time data. The classic example
                is a <em>chat room</em>: when a user sends a message, your application echoes that message back to the other Peers.
            </li>
        </ul>
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        WebSockets's terminology is quite simple: an <code><em>Endpoint</em></code> is a group
        of <code><em>Peers</em></code> (users) connected together and that your application manages. 
        A WebSocket <code>Endpoint</code> can receive and send <code><em>text messages</em></code>
        and <code><em>binary messages</em></code> from and to the Peers.
    </p>
    <p>
        Your application can manage multiple <code>Endpoints</code>, each of them with its own set of <code>Peers</code>. 
        Grouping Peers into separate <code>Endpoints</code> can be useful so you can easily send a specific message 
        to a specific group of Peers only. Also, each <code>Endpoint</code> may have some different level of 
        security associated with it:
        some users may be allowed to connect to some <code>Endpoints</code>, but not to some others.
    </p>
    
</section>

{#==========================================
Quick Example
==========================================#}     
<section id="websockets_quick_example">
    <h4>
        <a class="anchor_small" href="#websockets_quick_example" title="permanent link"></a>
        Quick Example
    </h4>
    
    <p>
        Here's a quick example on how to use WebSockets. Each part of this example will be explained in more details
        in following sections. You can try this example live on the 
        <img class="inlineIcon" src="/public/images/icons/run.png" /><a href="/demos-tutorials/websockets"><em>WebSockets demo</em></a> page.
    </p>
    <p>
        The source code for this example is:
        <ul>
            <li>
                WebSocket controller: <a href="https://github.com/spincast/spincast-framework/blob/master/spincast-website/src/main/java/org/spincast/website/controllers/WebsocketsDemoEchoAllController.java">WebsocketsDemoEchoAllController.java</a>
            </li>
            <li>
                HTML page: <a href="https://github.com/spincast/spincast-framework/blob/master/spincast-website/src/main/resources/templates/demos/websockets.html">websockets.html</a>
            </li>
        </ul>
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        First, we define a <code>WebSocket Route</code>:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java"
>router.websocket("/chat").handle(chatWebsocketController);</pre>
            </p>
        </div>
    </p>  
    <p>
        The <em>"chatWebsocketController"</em> is an instance of a class that implements the <code>WebsocketController</code>
        interface. This component is responsible for handling all the WebSocket events:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java"
>public class ChatWebsocketController 
        implements WebsocketController&lt;DefaultRequestContext, DefaultWebsocketContext&gt; {

    private WebsocketEndpointManager endpointManager;

    protected WebsocketEndpointManager getEndpointManager() {
        return this.endpointManager;
    }

    @Override
    public WebsocketConnectionConfig onPeerPreConnect(DefaultRequestContext context) {
        
        return new WebsocketConnectionConfig() {

            @Override
            public String getEndpointId() {
                return "chatEndpoint";
            }

            @Override
            public String getPeerId() {
                return "peer_" + UUID.randomUUID().toString();
            }
        };
    }

    @Override
    public void onEndpointReady(WebsocketEndpointManager endpointManager) {
        this.endpointManager = endpointManager;
    }
    
    @Override
    public void onPeerConnected(DefaultWebsocketContext context) {
        context.sendMessageToCurrentPeer("Your peer id is " + context.getPeerId());
    }
    
    @Override
    public void onPeerMessage(DefaultWebsocketContext context, String message) {
        getEndpointManager().sendMessage("Peer '" + context.getPeerId() + 
                "' sent a message: " + message);
    }

    @Override
    public void onPeerMessage(DefaultWebsocketContext context, byte[] message) {
    }

    @Override
    public void onPeerClosed(DefaultWebsocketContext context) {
    }

    @Override
    public void onEndpointClosed(String endpointId) {
    }
}</pre>
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">10-25</span> : Without going into too many details (we will do
                        that in the following sections), <code>onPeerPreConnect(...)</code> is a method called
                        <em>before</em> a new user is connected. In this example, we specify that this user should 
                        connect to the <em>"chatEndpoint"</em> <code>Endpoint</code> and that
                        its <code>Peer id</code> will be <em>"peer_"</em> followed by a random String.
                    </li>
                    <li>
                        <span class="code-line-nbr">27-30</span> : When a WebSocket Endpoint is ready to receive and send
                        messages, the <em>onEndpointReady(...)</em> method is called and gives us access 
                        to an <code><em>Endpoint Manager</em></code>.
                        We keep a reference to this manager since we are going to use it to send messages.
                    </li>   
                    <li>
                        <span class="code-line-nbr">32-35</span> : When the connection with a new Peer is established,
                        the <code>onPeerConnected(...)</code> method is called. In this example, as soon as the Peer is connected, 
                        we send him a message containing his <em>Peer id</em>.
                    </li>   
                    <li>
                        <span class="code-line-nbr">37-40</span> : When a Peer sends a message, 
                        the <em>onPeerMessage(...)</em> method is called.
                        In this example, we use the <code>Endpoint Manager</code> (which was received in the <em>onEndpointReady(...)</em> 
                        method [<span class="code-line-nbr">27-30</span>])
                        and we broadcast this message to all the Peers of the Endpoint.
                    </li>   
                </ul>
            </p>   
        </div>  
    </p>  
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Here's a quick client-side <code>HTML/javascript</code> code example, for a user to connect 
        to this Endpoint:
    </p>  
    <p>
        <div>
            <p>
                <pre class="ace ace-pebble"
>&lt;script&gt;
    var app = app || {};
    
    app.showcaseInit = function() {
        
        if(!window.WebSocket) {
            alert("Your browser does not support WebSockets.");
            return;
        }

        // Use "ws://" instead of "wss://" for an insecure 
        // connection, without SSL.
        app.showcaseWebsocket = new WebSocket("wss://" + location.host + "/chat");
        
        app.showcaseWebsocket.onopen = function(event) {
            console.log("WebSocket connection established!"); 
        };
        
        app.showcaseWebsocket.onclose = function(event) {
            console.log("WebSocket connection closed."); 
        };
        
        app.showcaseWebsocket.onmessage = function(event) {
            console.log(event.data); 
        };   
    };
    
    app.sendWebsocketMessage = function sendWebsocketMessage(message) {
        
        if(!window.WebSocket) {
            return;
        }
        if(app.showcaseWebsocket.readyState != WebSocket.OPEN) {
            console.log("The WebSocket connection is not open."); 
            return;
        }
        
        app.showcaseWebsocket.send(message);
    };
    
    app.showcaseInit();
    
&lt;/script&gt;

&lt;form onsubmit="return false;"&gt;
    &lt;input type="text" name="message" value="hi!"/&gt;
    &lt;input type="button" value="send" 
           onclick="app.sendWebsocketMessage(this.form.message.value)"/&gt;
&lt;/form&gt;
</pre> 
            </p>
        </div>
    </p>  
</section>  
   
{#==========================================
WebSocket Routing
==========================================#}     
<section id="websockets_routing">
    <h4>
        <a class="anchor_small" href="#websockets_routing" title="permanent link"></a>
        WebSocket Routing
    </h4>
    
    <p>
        The WebSocketRroutes are defined similarly to regular Routes, using
        Spincast's <a class="javadoc" href="/public/javadoc/org/spincast/core/routing/Router.html">Router</a>. But, instead of beginning the creation 
        of the Route with the <code>HTTP</code> method, like 
        <code>GET(...)</code> or <code>POST(...)</code>, you use <code><em>websocket(...)</em></code>:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java"
>router.websocket("/chat") ...</pre> 
            </p>
        </div>
    </p>  
    <p>
        There are fewer options available when creating a WebSocket Route compared to a regular HTTP Route. Here are
        the available ones...
    </p>
    <p> 
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        You can set
        an <code>id</code> for the Route. This allows you to identify the Route so you can refer to it
        later on, delete it, etc:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java"
>router.websocket("/chat")
      .id("chat-endpoint") ...</pre> 
            </p>
        </div>
    </p>  
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        You can also add "before" <code>Filters</code>, inline. Note that you can <em>not</em> add
        "after" <code>Filters</code> to a WebSocket Route because, as soon as the
        WebSocket connection is established, the <code>HTTP</code> request is over.
        But "before" <code>Filters</code> are perfectly fine since they applied to the 
        <code>HTTP</code> request <em>before</em> it is upgraded to a WebSocket connection. For the
        same reason, <em>global</em> "before" <code>Filters</code> (defined using something like 
        <code>router.ALL(...).pos(-10)</code>) will be applied during a
        WebSocket Route processing, but not the global "after" <code>Filters</code> (defined using 
        a position greater than "0").
    </p>
    <p>
        Here's an example of inline "before" <code>Filters</code>, on a WebSocket Route:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java"
>router.websocket("/chat")
      .id("chat-endpoint")
      .before(beforeFilter1) 
      .before(beforeFilter2) ...</pre> 
            </p>
        </div>
    </p>  
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Finally, like you do during the creating of a regular Route, you <em>save</em> the WebSocket Route. The 
        <code>handle(...)</code> method for a WebSocket Route takes a <a href="#websockets_controllers">WebSocket Controller</a>, 
        not a <code>Route Handler</code> as regular HTTP Routes do.
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java"
>router.websocket("/chat")
      .id("chat-endpoint")
      .before(beforeFilter1) 
      .before(beforeFilter2)
      .handle(chatWebsocketController);</pre> 
            </p>
        </div>
    </p>  
</section>
     
            
{#==========================================
WebSocket Controllers
==========================================#}     
<section id="websockets_controllers">
    <h4>
        <a class="anchor_small" href="#websockets_controllers" title="permanent link"></a>
        WebSocket Controllers
    </h4>
    
    <p>
        WebSocket Routes require a dedicated Controller as an handler. This Controller 
        is responsible for receiving the various WebSocket <em>events</em> occurring during the
        connection.
    </p>
    <p>
        You create a WebSocket Controller by implementing the 
        <a class="javadoc" href="/public/javadoc/org/spincast/core/websocket/WebsocketController.html"><code>WebsocketController</code></a> interface.
        
    </p>
    <h5>
        <a class="anchor_small" href="#websockets_controllers_events" id="websockets_controllers_events" title="permanent link"></a>
        The WebSocket events
    </h5>
    <p>
        Here are the methods a WebSocket Controller must implement, each of them associated with a specific WebSocket <code>event</code>:
        <ul class="apiList">
            <li>
                <code class="apiItem">WebsocketConnectionConfig <span>onPeerPreConnect</span>(R context)</code>
                <div class="well">
                    Called when a user requests a WebSocket connection. At this moment, the connection is not
                    yet established and you can allow or deny the request. You can also decide on which <code>Endpoint</code>
                    to connect the user to, and which <code>Peer id</code> to assign him.
                    
                    <div class="apiItemFooter">
                        @param context the <code>request context</code> of the initial <code>HTTP</code> request. Remember that
                        the WebSocket connection is not established yet!
                    </div>
                    
                </div>
            </li>
            
            <li>
                <code class="apiItem">void <span>onEndpointReady</span>(WebsocketEndpointManager endpointManager)</code>
                <div class="well">
                    Called when a new Endpoint is created within your application. The <code>Endpoint Manager</code> is passed
                    as a parameter on your should keep a reference to it. You'll use this Manager to send messages, to close
                    the connection with some Peers, etc.
                    <br /><br />
                    Note that this method <em>should not block</em>! More details <a href="#websockets_controllers_onEndpointReady">below</a>...
                    
                    <div class="apiItemFooter">
                        @param endpointManager the Endpoint Manager.
                    </div>
             
                </div>
            </li>
            
            <li>
                <code class="apiItem">void <span>onPeerConnected</span>(W context)</code>
                <div class="well">
                    Called when a new Peer is connected. At this point, the WebSocket connection is established with the
                    Peer and you can send him messages.
                    
                    <div class="apiItemFooter">
                        @param context the <code><a href="#websockets_context">WebSocket context</a></code>
                    </div>
                    
                </div>
            </li>
            
            <li>
                <code class="apiItem">void <span>onPeerMessage</span>(W context, String message)</code>
                <div class="well">
                    Called when a Peer sends a text message.
                    
                    <div class="apiItemFooter">
                        @param context the <code><a href="#websockets_context">WebSocket context</a></code>
                        <br />
                        @param message the text message sent by the Peer
                    </div>
            
                </div>
            </li>
            
            <li>
                <code class="apiItem">void <span>onPeerMessage</span>(W context, byte[] message)</code>
                <div class="well">
                    Called when a Peer sends a binary message.
                    
                    <div class="apiItemFooter">
                        @param context the <code><a href="#websockets_context">WebSocket context</a></code>
                        <br />
                        @param message the binary message sent by the Peer
                    </div>
            
                </div>
            </li>
            
            <li>
                <code class="apiItem">void <span>onPeerClosed</span>(W context)</code>
                <div class="well">
                    Called when the connection with a Peer is closed.
                    
                    <div class="apiItemFooter">
                        @param context the <code><a href="#websockets_context">WebSocket context</a></code>
                    </div>
            
                </div>
            </li>
            <li>
                <code class="apiItem">void <span>onEndpointClosed</span>(String endpointId)</code>
                <div class="well">
                    Called when the whole Endpoint is closed.
                    
                    <div class="apiItemFooter">
                        @param endpointId the id of the closed Endpoint
                    </div>
            
                </div>
            </li>
        </ul>
    </p> 
    
    <h5>
        <a class="anchor_small" href="#websockets_controllers_onPeerPreConnect" id="websockets_controllers_onPeerPreConnect" title="permanent link"></a>
        The <em>onPeerPreConnect(...)</em> event
    </h5>
    
    <p>
        The <code>onPeerPreConnect(...)</code> is called <em>before</em> the WebSocket connection is
        actually established with the user. The request, here, is still the original <code>HTTP</code> one, so you receive a
        <a href="#request_context">request context</a> as regular <code>Route Handlers</code> do.
    </p>
    <p>
        In that method, you have access to the user's <code>cookies</code> and to all the information about the initial
        <code>HTTP</code> request. This is a perfect place to decide if the requesting user should be allowed
        to connect to a WebSocket Endpoint or not. You may check if he is authenticated, if he has enough
        rights, etc. 
    </p>
    <p>
        If you return <code>null</code> from this method, the WebSocket connection process will
        be cancelled, and you are responsible for sending a response that makes sense to the user.
    </p>
    <p>
        For example:
        <div>
            <p>
                <pre class="ace ace-java"
>public WebsocketConnectionConfig onPeerPreConnect(DefaultRequestContext context) {

    String sessionId = context.request().getCookie("sessionId");
    if(sessionId == null || !canUserAccessWebsocketEndpoint(sessionId)) {
        context.response().setStatusCode(HttpStatus.SC_FORBIDDEN);
        return null;
    }

    return new WebsocketConnectionConfig() {

        @Override
        public String getEndpointId() {
            return "someEndpoint";
        }

        @Override
        public String getPeerId() {
            return "peer_" + encrypt(sessionIdCookie.getValue());
        }
    };
}</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">1</span> : When a user requests a WebSocket connection, 
                        the <code>onPeerPreConnect(...)</code>
                        method of the associated Controller is called. Note that here we receive the default <code>DefaultRequestContext</code>
                        request context, but if you are using a 
                        <a href="#extending_request_context">custom request context type</a>, you would
                        receive an object of your custom type (<code><em>AppRequestContext</em></code>, for example).
                    </li> 
                    <li>
                        <span class="code-line-nbr">3</span> : We get the session id of the current user using
                        a <em>"sessionId"</em> cookie (or any other way).
                    </li> 
                    <li>
                        <span class="code-line-nbr">4-7</span> : If the <em>"sessionId"</em> cookie is not found or if
                        the user associated with this session doesn't have enough rights to
                        access a WebSocket Endpoint, we set the response status as <code>Forbidden</code>
                        and we return <code>null</code>. By returning <code>null</code>, the WebSocket connection
                        process is cancelled and the <code>HTTP</code> response is sent as is.
                    </li> 
                    <li>
                        <span class="code-line-nbr">9-20</span> : If the user is allowed to access a WebSocket Endpoint, we
                        return the information required for that connection. We'll look at that <code>WebsocketConnectionConfig</code> 
                        object in the next section.
                    </li>  
                </ul>
            </p>  
            
        </div>
    </p>  
    
    <h5>
        <a class="anchor_small" href="#websockets_controllers_WebsocketConnectionConfig" id="websockets_controllers_WebsocketConnectionConfig" title="permanent link"></a>
        The <em>WebsocketConnectionConfig(...)</em> object
    </h5>

    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Once you decided that a user can connect to a WebSocket Endpoint, you return an instance of
        <a class="javadoc" href="/public/javadoc/org/spincast/core/websocket/WebsocketConnectionConfig.html">WebsocketConnectionConfig</a> from 
        the <code>onPeerPreConnect(...)</code> method. 
    </p>
    <p>
        In this object, you have to specify two things:
        <ul>
            <li>
                The <code>Endpoint id</code> to which the user should be connected to. 
                Note that you <em>can't</em> use the id of an Endpoint that
                is already managed by another Controller, otherwise an exception is thrown. If you use <code>null</code>
                here, a random Endpoint id will be generated. 
            </li>
            <li>
                The <code>Peer id</code> to assign to the user. Each Peer id must be unique inside a
                given Endpoint, otherwise an exception is thrown. If you return <code>null</code>
                here, a random id will be generated. 
            </li>
        </ul>
    </p>
    
    <h5>
        <a class="anchor_small" href="#websockets_controllers_multiple_endpoints" id="websockets_controllers_multiple_endpoints" title="permanent link"></a>
        Multiple Endpoints
    </h5>
    
    <p>
        Note that a single <code>WebSocket Controller</code> can manage <em>multiple</em> Endpoints. The Endpoints are
        not hardcoded when the application starts, you dynamically create them, on demand. Simply by connecting
        a first Peer using a new <code>Endpoint id</code>, you create the required Endpoint. This allows your Controller
        to "group" some Peers together, for any reason you may find useful. For example, you may have a
        chat application with multiple "rooms": each room would be a specific Endpoint, with a set of Peers
        connected to it.
    </p>
    <p>
        If the <code>Endpoint id</code> you return in the <code>WebsocketConnectionConfig</code> object is the 
        one of an existing Endpoint, the user will be
        connected to it. Next time you send a message using the associated <code>Manager</code>, this new Peer will
        receive it.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        If your Controller creates more than one Endpoint, you have to keep the <code>Managers</code> for
        each of those Endpoints!
    </p>
    <p>
        For example:
        <div>
            <p>
                <pre class="ace ace-java"
>public class MyWebsocketController 
        implements WebsocketController&lt;DefaultRequestContext, DefaultWebsocketContext&gt; {

    private final Map&lt;String, WebsocketEndpointManager&gt; 
            endpointManagers = new HashMap&lt;String, WebsocketEndpointManager&gt;();

    protected Map&lt;String, WebsocketEndpointManager&gt; getEndpointManagers() {
        return this.endpointManagers;
    }

    protected WebsocketEndpointManager getEndpointManager(String endpointId) {
        return getEndpointManagers().get(endpointId);
    }

    @Override
    public WebsocketConnectionConfig onPeerPreConnect(DefaultRequestContext context) {
        
        return new WebsocketConnectionConfig() {

            @Override
            public String getEndpointId() {
                return "endpoint_" + RandomUtils.nextInt(1, 11);
            }

            @Override
            public String getPeerId() {
                return null;
            }
        };
    }

    @Override
    public void onEndpointReady(WebsocketEndpointManager endpointManager) {
        getEndpointManagers().set(endpointManager.getEndpointId(), endpointManager);
    }

    @Override
    public void onPeerMessage(DefaultWebsocketContext context, String message) {
        getEndpointManager(context.getEndpointId()).sendMessage(message);
    }
    
    @Override
    public void onEndpointClosed(String endpointId) {
        getEndpointManagers().remove(endpointId);
    }

    @Override
    public void onPeerConnected(DefaultWebsocketContext context) {
    }

    @Override
    public void onPeerMessage(DefaultWebsocketContext context, byte[] message) {
    }

    @Override
    public void onPeerClosed(DefaultWebsocketContext context) {
    }
}</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">4-5</span> : Here, our Controller will manage more than one
                        Endpoints, so we create a <code>Map</code> to keep the association between each Endpoint
                        and its <code>WebSocket Manager</code>.
                    </li> 
                    <li>
                        <span class="code-line-nbr">20-23</span> : As the <code>Endpoint id</code> to use, this example 
                        returns a random id between 10 different possibilities, randomly distributed to the connecting Peers. 
                        In other words, our Controller is going 
                        to manage up to 10 Endpoints, from "endpoint_1" to "endpoint_10".
                    </li> 
                    <li>
                        <span class="code-line-nbr">25-28</span> : By returning <code>null</code> as the
                        <code>Peer id</code>, a random id will be generated.
                    </li> 
                    <li>
                        <span class="code-line-nbr">32-35</span> : When an Endpoint is created, we receive its
                        <code>Manager</code> and we add it to our <code>endpointManagers</code> map, using the 
                        <code>Endpoint id</code> as the key. Our <code>onEndpointReady</code> method may be called up 
                        to 10 times, one time for each Endpoint our Controller may create.
                    </li> 
                    <li>
                        <span class="code-line-nbr">37-40</span> : Since we manage more than one Endpoints,
                        we have to use the right <code>Manager</code> when sending a message!
                        Here, we echo back any message received by a Peer, to all Peers connected to the same 
                        Endpoint.
                    </li> 
                    <li>
                        <span class="code-line-nbr">42-45</span> : When an Endpoint is closed, we don't need its
                        <code>Manager</code> anymore so we remove it from our <code>endpointManagers</code> map.
                    </li> 
                </ul>
            </p>  
            
        </div>
    </p> 
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Finally, note that a Controller can manage multiple WebSocket Endpoints, but only one Controller
        can create and manage a given WebSocket Endpoint! If a Controller tries to connect a Peer to an Endpoint
        that is already managed by another Controller, an exception is thrown.
    </p>
    
    <h5>
        <a class="anchor_small" href="#websockets_controllers_onEndpointReady" id="websockets_controllers_onEndpointReady" title="permanent link"></a>
        The onEndpointReady(...) method should not block
    </h5>
    
    <p>
        It's important to know that the <code>onEndpointReady(...)</code> method is called
        <em>synchronously</em> by Spincast, when the connection with the very first Peer 
        is being established. This means that this method <em>should not block</em>
        or the connection with the first Peer will never succeed!
    </p>
    <p>
        Spincast calls <code>onEndpointReady(...)</code> synchronously to make sure you have access 
        to the Endpoint <code>Manager</code> <em>before</em>
        the first Peer is connected and therefore <em>before</em> you start receiving 
        events from him.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        You may be tempted to start some kind of <em>loop</em> in this  <code>onEndpointReady(...)</code> method, to
        send messages to the connected Peers, at some interval. Instead, start 
        a new <code>Thread</code> to run the loop, and let the current thread continue.
    </p>
    <p>
        In the following example, we will send the current time to all Peers connected to the Endpoint, every second.
        We do so without blocking the <code>onEndpointReady(...)</code> method :
        <div>
            <p>
                <pre class="ace ace-java"
>public void onEndpointReady(WebsocketEndpointManager endpointManager) {

    getEndpointManagers().set(endpointManager.getEndpointId(), endpointManager);

    final String endpointId = endpointManager.getEndpointId();

    Thread sendMessageThread = new Thread(new Runnable() {

        @Override
        public void run() {

            while(true) {
            
                WebsocketEndpointManager manager = getEndpointManager(endpointId);
                if(manager == null) {
                    break;
                }

                manager.sendMessage("Time: " + new Date().toString());

                try {
                    Thread.sleep(1000);
                } catch(InterruptedException e) {
                    break;
                }
            }
        }
    });
    sendMessageThread.start();
    
}</pre> 
            </p>
        </div>
    </p> 

    <h5>
        <a class="anchor_small" href="#websockets_controllers_configs" id="websockets_controllers_configs" title="permanent link"></a>
        Automatic pings and other configurations
    </h5>
    
    <p>
        By default, <code>pings</code> are automatically sent to each Peer every 20 seconds or so. This 
        validates that the Peers are still connected. When those pings find that a connection has been
        closed, <code>onPeerClosed(...)</code> is called on the WebSocket Controller.
    </p>
    <p>
        You can turn on/off those automatic pings and change other configurations, depending on the
        <code>Server</code> implementation you use. 
        Here are the <a class="javadoc" href="/public/javadoc/org/spincast/plugins/undertow/config/SpincastUndertowConfig.html">configurations</a>
        available when using the default Server, Undertow.
    </p>
</section>     

{#==========================================
WebSocket context
==========================================#}  
<section id="websockets_context">
    <h3>
        <a class="anchor" href="#websockets_context" title="permanent link"></a>
        The WebSocket context
    </h3>
    
    <p>
        Most methods of a <code>WebSocket Controller</code> receive a <code>WebSocket context</code>.
        This context object is similar to a <a href="#request_context">Request Context</a> received
        by a regular <code>Route Handler</code> :
        it gives access to information about the event (the 
        <code>Endpoint</code>, the <code>Peer</code>, etc.) and also provides easy access to 
        utility methods and <code>add-ons</code>.
    </p>
    <p>
        WebSocket specific methods :
        <ul>
            <li>
                <code>getEndpointId()</code>: The id of the Endpoint the current Peer is connected to.
            </li>
            <li>
                <code>getPeerId()</code>: The id of the current Peer.
            </li>
            <li>
                <code>sendMessageToCurrentPeer(String message)</code>: Sends a text message to the
                current Peer.
            </li>
            <li>
                <code>sendMessageToCurrentPeer(byte[] message)</code>: Sends a binary message to the
                current Peer.
            </li>
            <li>
                <code>closeConnectionWithCurrentPeer()</code>: Closes the connection with the
                current Peer.
            </li>
            
        </ul>
    </p>
    <p>
        Utility methods and add-ons:    
        <ul>
            <li>
                <code>getLocaleToUse()</code>: The best Locale to use for this Peer, as resolved during the
                initial <code>HTTP</code> request.
            </li>
            <li>
                <code>getTimeZoneToUse()</code>: The best TimeZone to use for this Peer.
            </li>
            <li>
                <code>json()</code>: Easy access to the <a class="javadoc" href="/public/javadoc/org/spincast/core/json/JsonManager.html">JsonManager</a>.
            </li>
            <li>
                <code>xml()</code>: Easy access to the <a class="javadoc" href="/public/javadoc/org/spincast/core/xml/XmlManager.html">XMLManager</a>.
            </li>
            <li>
                <code>templating()</code>: Easy access to the <a class="javadoc" href="/public/javadoc/org/spincast/core/templating/TemplatingEngine.html">TemplatingEngine</a>.
            </li>
            <li>
                <code>guice()</code>: Easy access to the application's Guice context.
            </li>
        </ul>
    </p>

</section>

{#==========================================
Extending the WebSocket context
==========================================#}  
<section id="websockets_extending_context">
    <h3>
        <a class="anchor" href="#websockets_extending_context" title="permanent link"></a>
        Extending the WebSocket context
    </h3>
    
    <p>
        The same way you can extend the <code>Request Context</code> type, which is the
        object passed to your <code>Route Handlers</code> for regular <code>HTTP</code> requests, you can also extend the
        <code>WebSocket Context</code> type, passed to your WebSocket Controller, when an event occurs.
    </p>
    <p>
        First, make sure you read the <a href="#extending_request_context">Extending the Request Context</a> section : it
        contains more details and the process of extending the WebSocket Context is very similar!
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        The first thing to do is to create a custom interface for the new <code>WebSocket Context</code> type :
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java"
>public interface AppWebsocketContext extends WebsocketContext&lt;AppWebsocketContext&gt; {
    public void customMethod(String message);
}</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">1</span> : A custom WebSocket context type extends the
                        base <a class="javadoc" href="/public/javadoc/org/spincast/core/websocket/WebsocketContext.html">WebsocketContext</a>
                        interface and parameterizes it using its <em>own</em> type.
                    </li> 
                </ul>
            </p>  
            
        </div>
    </p>  
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Then, we provide an implementation for that custom interface:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java"
>public class AppWebsocketContextDefault extends WebsocketContextBase&lt;AppWebsocketContext&gt;
                                                implements AppWebsocketContext {

    @AssistedInject
    public AppWebsocketContextDefault(@Assisted("endpointId") String endpointId,
                                      @Assisted("peerId") String peerId,
                                      @Assisted WebsocketPeerManager peerManager,
                                      WebsocketContextBaseDeps&lt;AppWebsocketContext&gt; deps) {
        super(endpointId,
              peerId,
              peerManager,
              deps);
    }

    @Override
    public void customMethod(String message) {
        sendMessageToCurrentPeer("customMethod: " + message);
    }
}</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">1-2</span> : The implementation extends 
                        <a class="javadoc" href="/public/javadoc/org/spincast/core/websocket/WebsocketContextBase.html">WebsocketContextBase</a>
                        so all the default methods/add-ons are kept. Of course, it also implements 
                        our custom <code>AppWebsocketContext</code>.
                    </li> 
                    <li>
                        <span class="code-line-nbr">4-13</span> : Don't worry about this scary constructor too much,
                        just add it as such and it should work. For the curious, the annotations indicate 
                        that this object will be created using
                        an <a href="https://github.com/google/guice/wiki/AssistedInject">assisted factory</a>.
                    </li> 
                    <li>
                        <span class="code-line-nbr">15-18</span> : We implement our custom method. This dummy example simply
                        sends a message to the current Peer, prefixed with <em>"customMethod: "</em>. Note that the 
                        <code>sendMessageToCurrentPeer(...)</code> method is inherited from <code>WebsocketContextBase</code>.
                    </li> 
                </ul>
            </p>  
            
        </div>
    </p> 
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Finally, you must let Spincast know about your custom <code>WebSocket Context</code> type. 
        This is done by using the 
        <code>websocketContextImplementationClass(...)</code> of the
        <a href="#boot_bootstrapper">Bootstrapper</a> :
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java" data-ace-hi="5,12,5,82"
>public static void main(String[] args) {

    Spincast.configure()
            .module(new AppModule())
            .requestContextImplementationClass(AppRequestContextDefault.class)
            .websocketContextImplementationClass(AppWebsocketContextDefault.class)
            .init(args);
    //....
}</pre>

            </p> 
        </div>
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        If you both extended the <code>Request Context</code> type and the <code>WebSocket Context</code> type, the
        parameterized version of your Router would look like :
        <code>Router&lt;AppRequestContext, AppWebsocketContext&gt;</code>.
    </p>
    <p>
        But you could also create an unparameterized version of it, for easier usage! :
    <p>
        <div>
            <p>
                <pre class="ace ace-java"
>public interface AppRouter extends Router&lt;AppRequestContext, AppWebsocketContext&gt; {
    // nothing required
}</pre> 
            </p>
        </div>
    </p>   
    <p>
        Note that if you use the <a href="#quick_start">Quick Start</a> to start your application, both 
        the <code>Request Context</code> type <em>and</em> the <code>WebSocket Context</code> type have
        already been extended and the unparameterized routing components have already been created for you!
    <p>
</section>
