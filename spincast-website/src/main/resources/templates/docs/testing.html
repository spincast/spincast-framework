{#==========================================
Docs : "Testing"
==========================================#}

<section id="testing">
    <h3>
        <a class="anchor" href="#testing" title="permanent link"></a>
        Testing
    </h3>

    <p>
        Spincast provides some nice testing utilities. You
        obviously don't <em>have</em> to use those to test your Spincast application, 
        you may already have your favorite testing toolbox and be happy with it. 
        But those utilities are heavily used to test 
        Spincast itself, and we think they are an easy, fun, and very solid testing foundation.
    </p>
    <p>
        First, Spincast comes with a <a href="#testing_runner">custom JUnit runner</a> which allows testing
        <em>using a Guice context</em> really easily. But, the biggest feature is to be able 
        to test your real application itself, <em>without even changing the
        way it is bootstrapped</em>. This is possible because of the <a href="#testing_guice_tweaker">Guice Tweaker</a>
        component which allows to indirectly mock or extend some components.
    </p>

</section>

{#==========================================
Installation
==========================================#}     
<section id="testing_installation">
    <h4>
        <a class="anchor_small" href="#testing_installation" title="permanent link"></a>
        Installation
    </h4>
    
    <p>
        Add this Maven artifact to your project to get access to the Spincast testing utilities:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-xml"
>&lt;dependency&gt;
    &lt;groupId&gt;org.spincast&lt;/groupId&gt;
    &lt;artifactId&gt;spincast-testing-default&lt;/artifactId&gt;
    &lt;version&gt;{{spincast.spincastCurrrentVersion}}&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre> 
            </p>
        </div>
    </p> 
    <p>
        Then, make your test classes extend <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/SpincastTestBase.html">SpincastTestBase</a>
        or one of its <a href="#testing_base_classes">children classes</a>. 
    </p>
    <p>
    	<img class="inlineIcon" src="/public/images/icons/tipy.png" /> 
        Most of the time, you'll want to extend
        <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/AppBasedTestingBase.html">AppBasedTestingBase</a>, or
        <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/AppBasedDefaultContextTypesTestingBase.html">AppBasedDefaultContextTypesTestingBase</a>
        if your application uses the default request context types.
    </p>
     
</section>

{#==========================================
Testing demo
==========================================#}     
<section id="testing_demo">
    <h4>
        <a class="anchor_small" href="#testing_demo" title="permanent link"></a>
        Demo
    </h4>
    <p>
        In this demo, we're going to test a simple application which only has
        one endpoint : <code>"/sum"</code>. The <code>Route Handler</code>
        associated with this endpoint is going to receive two numbers, will
        add them up, and will return the result as a
        <code>Json</code> object. Here's the response we would be expecting from the <code>"/sum"</code> endpoint when sending the 
        parameters <code>"first" = "1"</code> and <code>"second" = "2"</code> :
        
        <div>
            <p>
                <pre class="ace ace-json"
>{
  "result": "3"
}</pre> 
            </p>
        </div> 
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/tipy.png" />
        You can download that <a href="/public/demo-apps/spincast-demos-sum.zip">Sum application</a> [.zip]
        if you want to try it by yourself or look at its code directly.
    </p>
    
    <p>
        First, let's have a quick look at how the demo application is bootstrapped :
        
        <div>
            <p>
                <pre class="ace ace-java"
>public class App {

    public static void main(String[] args) {
        Spincast.configure()
                .module(new AppModule())
                .init(args);
    }

    @Inject
    protected void init(DefaultRouter router,
                        AppController ctrl,
                        Server server) {

        router.POST("/sum").handle(ctrl::sumRoute);
        server.start();
    }
}</pre> 
            </p>
            
            The interesting lines to note here are <span class="code-line-nbr">4-6</span> : we
            use the standard <a href="http://spincast.loc:44420/documentation#boot_bootstrapper">Bootstrapper</a> to start 
            everything! We'll see that, without modifying
            this bootstrapping process, we'll still be able to tweak the Guice context, to mock
            some components.
            
        </div> 
    </p>
    <p>
        Let's write a first test class :
        <div>
            <p>
                <pre class="ace ace-java"
>

public class SumTest extends AppBasedDefaultContextTypesTestingBase {

    @Override
    protected void callAppMainMethod() {
        App.main(null);
    }
    
    @Override
    protected AppTestingConfigs getAppTestingConfigs() {
        return new AppTestingConfigs() {

            @Override
            public boolean isBindAppClass() {
                return true;
            }

            @Override
            public Class&lt;? extends SpincastConfig&gt; getSpincastConfigTestingImplementationClass() {
                return SpincastConfigTestingDefault.class;
            }

            @Override
            public Class&lt;?&gt; getAppConfigTestingImplementationClass() {
                return null;
            }

            @Override
            public Class&lt;?&gt; getAppConfigInterface() {
                return null;
            }
        };
    }

    @Inject
    private JsonManager jsonManager;

    @Test
    public void validRequest() throws Exception {
        // TODO...
    }
}</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">2</span> : Our test class extends 
                        <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/AppBasedDefaultContextTypesTestingBase.html">AppBasedDefaultContextTypesTestingBase</a>.
                        This class is a child of <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/SpincastTestBase.html">SpincastTestBase</a> and therefore allows
                        us to use all the tools Spincast testing provides. Note there are other base classes you can extend, we're going to
                        <a href="#testing_base_classes">look at them</a> soon.
                    </li>
                    <li>
                        <span class="code-line-nbr">4-7</span> : The base class we are using requires that we implement the
                        <code>callAppMainMethod()</code> method. In this method we have to initialize the application to test. This is
                        easily done by calling its <code>main(...)</code> method.
                    </li>
                    <li>
                        <span class="code-line-nbr">9-33</span> : We also have to implement the <code>getAppTestingConfigs()</code>
                        method. This is to provide Spincast informations about the configurations we want to use when running
                        this test class. Have a look at the <a href="#testing_configurations">Testing configurations</a> 
                        section for more information!
                    </li>
                    <li>
                        <span class="code-line-nbr">35-36</span> : Here we can see Spincast testing in action! Our 
                        test class has now <em>full access to the Guice context of the application</em>. Therefore, we 
                        can inject any component we need. In this test class, we are going to
                        use the <a class="javadoc" href="/public/javadoc/org/spincast/core/json/JsonManager.html">JsonManager</a>.
                    </li>
                    <li>
                        <span class="code-line-nbr">38-41</span> : a first test to implement.
                    </li>
                    
                </ul>
            </p>  
        </div> 
    </p>
    <p>
        As you can see, simply by extending <code>AppBasedDefaultContextTypesTestingBase</code>, and by starting our
        application using its <code>main(...)</code> method, we can write integration tests targeting
        our running application, and we can use any components from its Guice context. There is some boilerplate
        code to write though (you nee to implement the <code>getAppTestingConfigs()</code> method, for example), and this why
        you would in general create a <em>base class</em> to serve as a parent for all your test classes!
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Let's implement our first test. We're going to validate that the <code>"/sum"</code> endpoint
        of the application works properly :
        
        <div>
            <p>
                <pre class="ace ace-java"
>   //...

    @Test
    public void validRequest() throws Exception {
    
        HttpResponse response = POST("/sum").addFormBodyFieldValue("first", "1")
                                            .addFormBodyFieldValue("second", "2")
                                            .addJsonAcceptHeader()
                                            .send();
    
        assertEquals(HttpStatus.SC_OK, response.getStatus());
        assertEquals(ContentTypeDefaults.JSON.getMainVariationWithUtf8Charset(),
                     response.getContentType());
    
        String content = response.getContentAsString();
        assertNotNull(content);
    
        JsonObject resultObj = this.jsonManager.fromString(content);
        assertNotNull(resultObj);
    
        assertEquals(new Integer(3), resultObj.getInteger("result"));
        assertNull(resultObj.getString("error", null));
    }
</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">6-9</span> : the <a href="/plugins/spincast-http-client">Spincast HTTP Client</a>
                        plugin is fully integrated into Spincast testing utilities. This allows us to
                        very easily send requests to test our application. We don't even have to
                        configure the <em>host</em> and <em>port</em> to use : Spincast will
                        automatically find and use those of our application.
                    </li>
                    <li>
                        <span class="code-line-nbr">11-13</span> : we validate that the response is a success
                        (<code>"200"</code>) and that the content-type is the expected
                        <code>"application/json"</code>.
                    </li>
                    <li>
                        <span class="code-line-nbr">15-16</span> : we get the content of the response as a String and we validate that
                        it is not <code>null</code>.
                    </li>
                    <li>
                        <span class="code-line-nbr">18-19</span> : we use the <code>JsonManager</code>
                        (injected previously) to convert the content to a <a href="/documentation#jsonobject">JsonObject</a>.
                    </li>
                    <li>
                        <span class="code-line-nbr">21-22</span> : we finally validate the result of the sum
                        and that no error occured.
                    </li>
                </ul>
            </p>  
        </div> 
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/tipy.png" />
        Note that we could also have retrieved the content of the response as a <code>JsonObject</code> 
        <em>directly</em>, by using <code><em>response.getContentAsJsonObject()</em></code> instead of 
        <code><em>response.getContentAsString()</em></code>. But we wanted to demonstrate the use of
        an injected component, so bear with us!
    </p>
    <p>
        If you look at <a href="https://github.com/spincast/spincast-framework/tree/master/spincast-website/demo-apps/sum/src/test/java/org/spincast/demos/sum/SumTest.java">the source</a>
        of this demo, you'll see two more tests in that first test class : one that
        tests the endpoint when a parameter is missing, and one that tests the endpoint when the sum overflows
        the maximum <code>Integer</code> value.
    </p>
    
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        Let's now write a second test class. In this one, we are going to show how
        easy it is to replace a binding, to mock a component.
    </p>
    <p>
        Let's say we simply want to test that the responses returned by our application
        are <em>gzipped</em>. We may not care about the actual result of calling the
        <code>"/sum"</code> endpoint, so we are going to "mock" it. This is a simple
        example, but the process involved is similar if you need to mock a
        <em>data source</em>, for example.
    </p>
    <p>
        Our second test class will look like this :
        
        <div>
            <p>
                <pre class="ace ace-java"
>

public class ResponseIsGzippedTest extends AppBasedDefaultContextTypesTestingBase {

    @Override
    protected void callAppMainMethod() {
        App.main(null);
    }
    
    @Override
    protected AppTestingConfigs getAppTestingConfigs() {
        return new AppTestingConfigs() {

            @Override
            public boolean isBindAppClass() {
                return true;
            }

            @Override
            public Class&lt;? extends SpincastConfig&gt; getSpincastConfigTestingImplementationClass() {
                return SpincastConfigTestingDefault.class;
            }

            @Override
            public Class&lt;?&gt; getAppConfigTestingImplementationClass() {
                return null;
            }

            @Override
            public Class&lt;?&gt; getAppConfigInterface() {
                return null;
            }
        };
    }

    public static class AppControllerTesting extends AppControllerDefault {

        @Override
        public void sumRoute(DefaultRequestContext context) {
            context.response().sendPlainText("42");
        }
    }

    @Override
    protected Module getExtraOverridingModule() {
        return new SpincastGuiceModuleBase() {

            @Override
            protected void configure() {
                bind(AppController.class).to(AppControllerTesting.class).in(Scopes.SINGLETON);
            }
        };
    }

    @Test
    public void isGzipped() throws Exception {
        // TODO...
    }
}</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">2</span> : this test class also extends 
                        <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/AppBasedDefaultContextTypesTestingBase.html">AppBasedDefaultContextTypesTestingBase</a>.
                    </li>
                    <li>
                        <span class="code-line-nbr">4-7</span> : we start our application.
                    </li>
                    <li>
                        <span class="code-line-nbr">9-33</span> : if we had created a <em>base class</em> for our tests, we could have 
						define the <code>getAppTestingConfigs()</code> there instead of having to repeat it in all test
						files!
                    </li>
                    <li>
                        <span class="code-line-nbr">35-41</span> : we create a <em>mock</em> controller by extending
                        the original one and replacing the <code>sumRoute(...)</code> <code>Route Handler</code>
                        so it always returns "42".
                    </li>
                    <li>
                        <span class="code-line-nbr">43-52</span> : We specify an <em>overriding module</em> to change the implementation
                        that will be used for the <code>AppController</code> binding. Under the hood, this is done
      					by the <a href="#testing_guice_tweaker">Guice Tweaker</a>.
                    </li>
                </ul>
            </p>  
        </div>  
    </p>
    <p>
        And let's write the test itself :
        
        <div>
            <p>
                <pre class="ace ace-java"
>    //...

    @Test
    public void isGzipped() throws Exception {
     
        HttpResponse response = POST("/sum").addFormBodyFieldValue("toto", "titi")
                                            .addJsonAcceptHeader()
                                            .send();
    
        assertTrue(response.isGzipped());
    
        assertEquals(HttpStatus.SC_OK, response.getStatus());
        assertEquals(ContentTypeDefaults.TEXT.getMainVariationWithUtf8Charset(),
                     response.getContentType());
        assertEquals("42", response.getContentAsString());  
    }
</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">6-8</span> : We can send pretty much anything here as the
                        parameters since the controller is mocked : they won't be validated.
                    </li>
                    <li>
                        <span class="code-line-nbr">10</span> : We validate that the response was gzipped.
                    </li>
                    <li>
                        <span class="code-line-nbr">12-15</span> : just to make sure our tweaking
                        is working properly.
                    </li>
                    
                </ul>
            </p>  
        </div>  
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Being able to change bindings like this is very powerful : you are testing your real application,
        as it is bootstrapped, without even changing its code. All is done <em>indirectly</em>, using 
        the Guice Tweaker.
    </p>
    
</section>

{#==========================================
Guice Tweaker
==========================================#}     
<section id="testing_guice_tweaker">
    <h4>
        <a class="anchor_small" href="#testing_guice_tweaker" title="permanent link"></a>
        Guice Tweaker
    </h4>
    
    <p>
        As we saw in the previous demo, we can tweak the Guice context of our application
        in order to test it. This is done by the 
        <a class="javadoc" href="/public/javadoc/org/spincast/core/guice/GuiceTweaker.html">GuiceTweaker</a>,
        a component which is part of the Spincast testing machanism.
    </p>
    <p>
        The Guice Tweaker is in fact a <a href="#plugins">plugin</a>. This plugin is special because
        it is applied even if it's not registered during the bootstrapping of the application.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/tipy.png" /> 
        It's important to know that the Guice Tweaker only works if you are using the
        standard <a href="#boot_bootstrapper">Bootstrapper</a>. It is implemented
        using a <code>ThreadLocal</code> that the bootstrapper will look for.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        The Guice Tweaker is created in the <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/SpincastTestBase.html">SpincastTestBase</a>
        class. By extending this class or one of <a href="#testing_base_classes">its children</a>, you have access to it.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        By default, the Guice Tweaker automatically modifies the <code>SpincastConfig</code>
        binding of the application when tests are run. This allows you to use testing configurations very easily
        (for example to make sure the server starts on a free port). The implementation class used
        for those configurations are specified in the <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/AppBasedTestingBase.html#getAppTestingConfigs--">getAppTestingConfigs()</a>
        method you have to implement. The Guice tweaker will use those informations and will create the required binding
        automatically. The default implementation for the <code>SpincastConfig</code> interface is 
        <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/utils/SpincastConfigTestingDefault.html">SpincastConfigTestingDefault</a>.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Those are the methods available, in a test file, to tweak your application :
        
        <ul>
            <li>
            	<p>
	                <strong><em>getAppTestingConfigs(...)</em></strong> : a section dedicated to this method 
	                <a href="#testing_configurations">follows next</a>.
            	</p>
            </li>
            <li>
                <strong><em>getExtraOverridingModule(...)</em></strong> : to make the Guice Tweaker
                add an extra module to the created Guice context.
            </li>
            <li>
                <strong><em>getExtraPlugins(...)</em></strong> :  to make the Guice Tweaker
                add extra plugins to the created Guice context.
            </li>
            <li>
                <strong><em>addExtraSystemProperties(...)</em></strong> : to add extra System properties
                before running the tests.
            </li>
            
        </ul>
    </p>
</section>

{#==========================================
Testing configurations
==========================================#}     
<section id="testing_configurations">
    <h4>
        <a class="anchor_small" href="#testing_configurations" title="permanent link"></a>
        The testing configurations (<code>getAppTestingConfigs()</code>)
    </h4>
    <p>
    	When running integration tests, you don't want to use the same configurations then the ones
    	you would when running the application directly. For example, you may want to provide a 
    	different <code>connection string</code> to use a mocked database instead of the real one.
    </p>
    <p>
    	As we saw in the previous section, the <a href="#testing_guice_tweaker">Guice Tweaker</a> allows you to
    	change some bindings when testing your application. But configurations is such an important component
    	to modify, when running tests, that Spincast forces you to specify which implementations to use for
    	those!
    </p>
    <p>
    	You specify the testing configurations by implementing the
    	<a class="javadoc" href="/public/javadoc/org/spincast/testing/core/AppBasedTestingBase.html#getAppTestingConfigs--">getAppTestingConfigs()</a>
    	method. This method must return an instance of 
    	<a class="javadoc" href="/public/javadoc/org/spincast/testing/core/AppTestingConfigs.html">AppTestingConfigs</a>. This
    	object tells Spincast :
    	
    	<ul>
    		<li>
    			<strong><em>getSpincastConfigTestingImplementationClass()</em></strong> : The implementation class to use for 
    			the <code>SpincastConfig</code> binding. In other words, this hook allows you to easily mock the
    			configurations used by Spincast core components. The default testing implementation is the provided
    			<a class="javadoc" href="/public/javadoc/org/spincast/testing/core/utils/SpincastConfigTestingDefault.html">SpincastConfigTestingDefault</a> 
    			class. You may want to have a look at this class when wrting your own since it shows how
    			to implement some useful things, such as finding a free port to use when starting the HTTP server.
    		</li>
    		<li>
    			<strong><em>getAppConfigInterface()</em></strong> : The interface of your custom app configurations
    			class. You can return <code>null</code> if you don't have a custom configurations class.
    		</li>
    		<li>
    			<strong><em>getAppConfigTestingImplementationClass()</em></strong> : The implementation class to use for 
    			your custom app configurations. You can return <code>null</code> if you don't have a custom configurations class.
    		</li>
    		<li>
    			<strong><em>isBindAppClass()</em></strong> : Should the App class itself (the class in which
			    <code>Spincast.init()</code> or <code>Spincast.configure()</code> is called) be bound?
				In general, if you are running
				<em>unit tests</em> and don't need to start any HTTP server, you are going to
				return <code>false</code>... That way, your main class
				(in general named "<code>App</code>") won't be bound and therefore won't start the
				server.
    		</li>
    		
    	</ul>
    </p>
    <p>
    	Spincast will use the informations returned by this object and will add all the required bindings
    	automatically. You don't need to do anything by yourself, for example by using the Guice Tweaker, to change the 
    	bindings for the configurations when running integration tests. You just need to implement the 
    	<code>getAppTestingConfigs()</code> method.
    </p>
    <p>
    	<img class="inlineIcon" src="/public/images/icons/tipy.png" />
    	In most applications, the testing implementation to use for the <code>SpincastConfig</code> interface and 
    	the one for your 
    	custom configurations interface will be the same! Indeed, if you follow
    	the <a href="#config_strategy_components">suggested way</a> of configuring your application, then your custom
    	configurations interface <code>AppConfig</code> extends <code>SpincastConfig</code>. 
    	
    </p>
    <p>
    	<img class="inlineIcon" src="/public/images/icons/tipy.png" />
    	Your testing configurations can often be shared between multiple tests classes.
    	It is therefore a good idea to create an abstract base class, named "AppTestingsBase" or something similar, 
    	to implement the <code>getAppTestingConfigs()</code> method there, and use
    	this base class as the parent for all your integration test classes. Have a look at
    	<a href="https://github.com/spincast/spincast-framework/blob/master/spincast-website/src/test/java/org/spincast/website/tests/WebsiteIntegrationTestBase.java">this base class</a> 
    	for an example.
    </p>
    <p>
    	<img class="inlineIcon" src="/public/images/icons/tipy.png" />
    	While mocking some configurations is often required, it's still a good
    	idea to make testing configurations as close as possible as the ones that are going to be used
    	<em>in production</em>. For example, returning <code>false</code> for the
    	<a class="javadoc" href="/public/javadoc/org/spincast/core/config/SpincastConfig.html#isDebugEnabled--">isDebugEnabled()</a>
    	method is suggested. That way, you can be confident that once your tests pass, your application will do well
    	in production.
    </p>
    <p>
    	<img class="inlineIcon" src="/public/images/icons/tipy.png" />
    	You can mock some <em>Environment Variables</em> used as configurations, by overriding the
    	<a class="javadoc" href="/public/javadoc/org/spincast/plugins/config/ConfigFinder.html#getEnvironmentVariables--">getEnvironmentVariables()</a>
    	method in your configurations implementation class.
    </p>
    
</section>

{#==========================================
Testing base classes
==========================================#}     
<section id="testing_base_classes">
    <h4>
        <a class="anchor_small" href="#testing_base_classes" title="permanent link"></a>
        Testing base classes
    </h4>
    
    <p>
        Multiple base classes are provided, depending on the needs of your test class. They all ultimately extend
        <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/SpincastTestBase.html">SpincastTestBase</a>,
        they all use the <a href="#testing_runner">Spincast JUnit runner</a> and
        all give access to <a href="#testing_guice_tweaker">Guice Tweaker</a>.
    </p>
    <p>
        Those test base classes are split into two main categories : those <em>based on your actual application</em> and those
        that are not. Most of the time, you do want to test using the Guice context of your application! But you may
        sometimes have components that can be unit tested without the full Guice context of your application.
    </p>
    <p>
        Those are the main testing base classes provided by Spincast. All of them can be modify using the Guice Tweaker&nbsp;:
    </p>
    <p>
        <strong>App based</strong>
        <br />
        <ul>
            <li>
                <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/AppBasedTestingBase.html">AppBasedTestingBase</a> :
                probably the most useful class. Using this class as a parent, your <em>full</em> application Guice context will be used
                to run the tests.
            </li>
            <li>
                <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/AppBasedDefaultContextTypesTestingBase.html">AppBasedDefaultContextTypesTestingBase</a> :
                Same as <code>AppBasedTestingBase</code>, but if you use the <em>default</em> request context type in your application, instead of
                a <a href="#extending_request_context">custom one</a>.
            </li>
        </ul>
    </p>
    <p>
        <strong>Not based on an app</strong>
        <br />
        <ul>
            <li>
                <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/NoAppTestingBase.html">NoAppTestingBase</a> : base class
                to use to test components using the default Guice context (the default plugins only). No application class is involved.
            </li>
            <li>
                <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/NoAppStartHttpServerTestingBase.html">NoAppStartHttpServerTestingBase</a> : 
                as <code>NoAppTestingBase</code>, but if you also need the HTTP server to be started! This base class will be responsible to
                start and stop the server.
            </li>
        </ul>
    </p>
</section>

{#==========================================
Spincast JUnit runner
==========================================#}         
<section id="testing_runner">
    <h4>
        <a class="anchor_small" href="#testing_runner" title="permanent link"></a>
        Spincast JUnit runner
    </h4>
    
    <p>
        Spincast's testing base classes all use a custom JUnit runner: 
        <a class="javadoc" href="/public/javadoc/org/spincast/testing/utils/SpincastJUnitRunner.html">SpincastJUnitRunner</a>.
    </p>
    <p>
        This custom runner has a couple of differences as compared with the default JUnit runner, 
        but the most important one is that instead of creating a new instance of the test class 
        before each test, this runner only creates <em>one</em> instance. 
    </p>
    <p>
        This way of running the tests works very well when a Guice context is involved.
        The Guice context is created when the test class is initialized, and then this context is used to run all the tests
        of the class. If Integration testing is used, then the HTTP Server 
        is started when the test class is initialized and it is used to run
        all the tests of the class.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Let's see in more details how the Spincast JUnit runner works :
    </p>
    <p>
        <ul>
            <li>
                First, a <code>beforeClass()</code> method is called. As opposed to a classic 
                JUnit's <code>@BeforeClass</code> annotated method, Spincast's <code>beforeClass()</code> method is
                <em>not static</em>. It is called when the test class is initialized.
            </li>
            <li>
                The <code>createInjector()</code> method is called in the <code>beforeClass()</code> method. This is where
                the Guice context will be created, by starting an application or explictly.
            </li>
            <li>
                The dependencies are automatically injected from the Guice context into the instance of the test class. 
                All your <code>@Inject</code> annotated fields and methods are fulfilled.
            </li>
            <li>
                If an exception occures during the execution of the <code>beforeClass()</code> method, 
                the <code>beforeClassException(...)</code> method will be called, the process will be stop and the tests won't be run.
            </li>
            <li>
                If no exception occures, the tests are then run.
            </li>
            <li>
                The <code>afterClass()</code> method is called. Like the <code>beforeClass()</code> method, this
                method is not static. Note that the <code>afterClass()</code> method won't be called if an exception occurred
                in the <code>beforeClass()</code> method.
            </li> 
        </ul>
    </p>
    <p>
        Since the Guice context is shared by all the tests of a test class, you have to make sure you reset everything 
        required before running a test. To do this, use JUnit's 
        <a href="https://github.com/junit-team/junit4/wiki/Test-fixtures">@Before</a> annotation, or 
        the <code>beforeTest()</code> and <code>afterTest()</code> method.
    </p>
    
    <h5>
        <a class="anchor_small" href="#testing_runner_features" id="testing_runner_features" title="permanent link"></a>
        Spincast JUnit runner features
    </h5>

    <p>
        <ul>
            <li>
                If your test class is annotated with
                <a class="javadoc" href="/public/javadoc/org/spincast/testing/utils/ExpectingBeforeClassException.html">@ExpectingBeforeClassException</a>
                then the <code>beforeClass()</code> method is expected to throw an exception! In other words, the test class will be
                shown by JUnit as a "success" only of the <code>beforeClass()</code> method throws an exception. This is useful,
                in integration testing, to validate that your application refuses some invalid configuration when 
                it starts, for example.
            </li>
            <li>
                If your test class (or a parent) implements
                <a class="javadoc" href="/public/javadoc/org/spincast/testing/utils/TestFailureListener.html">TestFailureListener</a>
                then the <code>testFailure(...)</code> method will be called each time a test fails. This
                allows you to add a breakpoint or some logs, and to inspect the context of the failure.
            </li>
            <li>
                You can use the <a class="javadoc" href="/public/javadoc/org/spincast/testing/utils/Repeat.html">@Repeat</a> annotation. 
                When added to the class itself, this annotation makes your test class loop X number of times. Note that the 
                <code>beforeClass()</code> and <code>afterClass()</code> methods will also be called X number of time, so the
                Guice context will be recreated each time.
                You can specify an amount of milliseconds to sleep between two loops, using the <code>sleep</code> parameter.
            </li>
            <li>
                You can also use the <a class="javadoc" href="/public/javadoc/org/spincast/testing/utils/Repeat.html">@Repeat</a> annotation
                <em>on a test</em>. This will make the test run X number of time during the execution of a test class
                loop.
            </li>
            <li>
                If your test class (or a parent) implements
                <a class="javadoc" href="/public/javadoc/org/spincast/testing/utils/RepeatedClassAfterMethodProvider.html">RepeatedClassAfterMethodProvider</a> 
                then the <code>afterClassLoops()</code> method will be called when all the loops of the test class have been
                run.
            </li>
        </ul>
    </p>
    <p>
        A quick note about the <code>@Repeat</code></a> annotation : this annotation should probably only be used 
        for <em>debugging</em> purpose! A test should always be reproducible and should probably not have
        to be run multiple times. But this annotation, in association with the 
        <code>testFailure(...)</code> method, can be a great help to debug a test
        which <em>sometimes</em> fails and you don't know why!
    </p>
    
</section>


{#==========================================
Managing cookies
==========================================#}         
<section id="testing_cookies">
    <h4>
        <a class="anchor_small" href="#testing_cookies" title="permanent link"></a>
        Managing cookies
    </h4>
    
    <p>
        A frequent need during integration testing is to be able to keep cookies across
        multiple requests... In doing so, the behavior of a real browser is simulated.
    </p>
    <p>
        To keep the cookies sent by a response, simple call
        <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/AppBasedTestingBase.html#saveResponseCookies-org.spincast.plugins.httpclient.HttpResponse-">saveResponseCookies(response)</a>
        when a valid response is received. Then, you can add back those cookies to a new request using 
        <code>.setCookies(getPreviousResponseCookies())</code>:
        
        <div>
            <p>
                <pre class="ace ace-java" data-ace-hi="3,0,3,29|6,22,6,63" 
>// First request, we save the cookies from the response...
HttpResponse response = GET("/one").send();
assertEquals(HttpStatus.SC_OK, response.getStatus());
saveResponseCookies(response);

// Second request, we resend the cookies!
response = GET("/two").setCookies(getPreviousResponseCookies()).send();
assertEquals(HttpStatus.SC_OK, response.getStatus());
saveResponseCookies(response);
</pre> 
            </p>
        </div>    
    </p>
    
</section>
    
    
    
    