{#==========================================
Docs : "Testing"
==========================================#}

<section id="testing">
    <h3>
        <a class="anchor" href="#testing" title="permanent link"></a>
        Testing
    </h3>

    <p>
        Spincast provides some nice testing utilities. You
        obviously don't <em>have</em> to use those to test your Spincast application, 
        you may already have your favorite testing toolbox and be happy with it. 
        But those utilities are heavily used to test 
        Spincast itself, and we think they are an easy, fun, and very solid testing foundation.
    </p>
    <p>
        First, Spincast comes with a <a href="#testing_runner">custom JUnit runner</a> which allows testing
        <em>using a Guice context</em> really easily. But, the biggest feature is to be able 
        to test your real application itself, <em>without even changing the
        way it is bootstrapped</em>. This is possible because of the <a href="#testing_guice_tweaker">Guice Tweaker</a>
        component which allows to indirectly mock or extend some components.
    </p>

</section>

{#==========================================
Installation
==========================================#}     
<section id="testing_installation">
    <h4>
        <a class="anchor_small" href="#testing_installation" title="permanent link"></a>
        Installation
    </h4>
    
    <p>
        Add this Maven artifact to your project to get access to the Spincast testing utilities:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-xml"
>&lt;dependency&gt;
    &lt;groupId&gt;org.spincast&lt;/groupId&gt;
    &lt;artifactId&gt;spincast-testing-default&lt;/artifactId&gt;
    &lt;version&gt;{{spincast.spincastCurrrentVersion}}&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre> 
            </p>
        </div>
    </p> 
    <p>
        Then, make your test classes extend <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/SpincastTestBase.html">SpincastTestBase</a>
        or one of its <a href="#testing_base_classes">children classes</a>.
    </p>
     
</section>

{#==========================================
Testing demo
==========================================#}     
<section id="testing_demo">
    <h4>
        <a class="anchor_small" href="#testing_demo" title="permanent link"></a>
        Demo
    </h4>
    <p>
        In this demo, we're going to test a simple application which only has
        one route : <code>"/sum"</code>. The <code>Route Handler</code>
        associated with this <code>Route</code> is going to receive two numbers, will
        add them up, and will return the result as a
        <code>Json</code> object. Here's the response we would be expecting from the <code>"/sum"</code> endpoint by sending the 
        parameters <code>"first" = "1"</code> and <code>"second" = "2"</code> :
        
        <div>
            <p>
                <pre class="ace ace-json"
>{
  "result": "3"
}</pre> 
            </p>
        </div> 
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/tipy.png" />
        You can download that <a href="/public/demo-apps/spincast-demos-sum.zip">Sum application</a> [.zip]
        if you want to try it by yourself or look at its code directly.
    </p>
    
    <p>
        First, let's have a quick look at how the demo application is bootstrapped :
        
        <div>
            <p>
                <pre class="ace ace-java"
>public class App {

    public static void main(String[] args) {
        Spincast.configure()
                .module(new AppModule())
                .init();
    }

    @Inject
    protected void init(DefaultRouter router,
                        AppController ctrl,
                        Server server) {

        router.POST("/sum").save(ctrl::sumRoute);
        server.start();
    }
}</pre> 
            </p>
            
            The interesting lines to note here are <span class="code-line-nbr">4-6</span> : we
            use the bootstrapper to start everything! We'll see that, without touching
            this bootstrapping, we'll still be able to modify the Guice context, to mock
            some components.
            
        </div> 
    </p>
    <p>
        Let's write a first test class :
        <div>
            <p>
                <pre class="ace ace-java"
>

public class SumTest extends IntegrationTestAppDefaultContextsBase {

    @Override
    protected void initApp() {
        App.main(null);
    }

    @Inject
    private JsonManager jsonManager;

    @Test
    public void validRequest() throws Exception {
        // TODO...
    }
}</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">2</span> : Our test class extends 
                        <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/IntegrationTestAppDefaultContextsBase.html">IntegrationTestAppDefaultContextsBase</a>.
                        This class is a child of <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/SpincastTestBase.html">SpincastTestBase</a> and therefore allows
                        us to use all the tools Spincast testing provides. Note there are other base classes you can extend, we're going to
                        <a href="#testing_base_classes">look at them</a> soon.
                    </li>
                    <li>
                        <span class="code-line-nbr">4-7</span> : The base class we are using requires that we implement the
                        <code>initApp()</code> method. In this method we have to start the application to test. This is
                        easily done by calling its <code>main(...)</code> method.
                    </li>
                    <li>
                        <span class="code-line-nbr">9-10</span> : Here we can see Spincast testing in action! Our 
                        test class has now <em>full access to the Guice context of the application</em>. Therefore, we 
                        can inject any component we need. In this test class, we are going to
                        use the <a class="javadoc" href="/public/javadoc/org/spincast/core/json/JsonManager.html">JsonManager</a>.
                    </li>
                    <li>
                        <span class="code-line-nbr">12-15</span> : a first test to implement.
                    </li>
                    
                </ul>
            </p>  
        </div> 
    </p>
    <p>
        As you can see, simply by extending <code>IntegrationTestAppDefaultContextsBase</code>, and by starting our
        application using its <code>main(...)</code> method, we can write integration tests targeting
        our running application, and we can use any components from its Guice context.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Let's implement that first test. We're going to validate that the <code>"/sum"</code> endpoint
        of our application works properly :
        
        <div>
            <p>
                <pre class="ace ace-java"
>@Test
public void validRequest() throws Exception {

    HttpResponse response = POST("/sum").addEntityFormDataValue("first", "1")
                                        .addEntityFormDataValue("second", "2")
                                        .addJsonAcceptHeader()
                                        .send();

    assertEquals(HttpStatus.SC_OK, response.getStatus());
    assertEquals(ContentTypeDefaults.JSON.getMainVariationWithUtf8Charset(),
                 response.getContentType());

    String content = response.getContentAsString();
    assertNotNull(content);

    JsonObject resultObj = this.jsonManager.fromString(content);
    assertNotNull(resultObj);

    assertEquals(new Integer(3), resultObj.getInteger("result"));
    assertNull(resultObj.getString("error", null));
}
</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">4-7</span> : the <a href="/plugins/spincast-http-client">Spincast HTTP Client</a>
                        plugin is fully integrated into Spincast testing utilities. This allows us to
                        very easily send requests to test our application. We don't even have to
                        configure the <em>host</em> and <em>port</em> to use : Spincast will
                        automatically find and use those of our application.
                    </li>
                    <li>
                        <span class="code-line-nbr">9-11</span> : we validate that the response is a success
                        (<code>"200"</code>) and that the content-type is the expected
                        <code>"application/json"</code>.
                    </li>
                    <li>
                        <span class="code-line-nbr">13-14</span> : we get the content of the response as a String and we validate that
                        it is not <code>null</code>.
                    </li>
                    <li>
                        <span class="code-line-nbr">16-17</span> : we use the <code>JsonManager</code>
                        (injected previously) to convert the content to a <a href="/documentation#jsonobject">JsonObject</a>.
                    </li>
                    <li>
                        <span class="code-line-nbr">19-20</span> : we finally validate the result of the sum
                        and that no error occured.
                    </li>
                </ul>
            </p>  
        </div> 
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/tipy.png" />
        Note that we could also have retrieved the content of the response as a <code>JsonObject</code> 
        <em>directly</em>, by using <code><em>response.getContentAsJsonObject()</em></code> instead of 
        <code><em>response.getContentAsString()</em></code>. But we wanted to demonstrate the use of
        an injected component, so bear with us!
    </p>
    <p>
        If you look at <a href="https://github.com/spincast/spincast-framework/tree/master/spincast-website/demo-apps/sum/src/test/java/org/spincast/demos/sum/SumTest.java">the source</a>
        of this demo, you'll see two more tests in that first test class : one that
        tests the endpoint when a parameter is missing, and one that tests the endpoint when the sum overflows
        the maximum <code>Integer</code> value.
    </p>
    
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" />
        Let's now write a second test class. In this one, we are going to show how
        easy it is to replace a binding, to mock a component.
    </p>
    <p>
        Let's say we simply want to test that the responses returned by our application
        are <em>gzipped</em>. We may not care about the actual result of calling the
        <code>"/sum"</code> endpoint, so we are going to "mock" it. This is a simple
        example, but the process involved is similar if you need to mock a
        <em>data source</em>, for example.
    </p>
    <p>
        Our second test class will look like this :
        
        <div>
            <p>
                <pre class="ace ace-java"
>

public class ResponseIsGzippedTest extends IntegrationTestAppDefaultContextsBase {

    @Override
    protected void initApp() {
        App.main(null);
    }

    public static class AppControllerTesting extends AppControllerDefault {

        @Override
        public void sumRoute(DefaultRequestContext context) {
            context.response().sendPlainText("42");
        }
    }

    @Override
    protected SpincastPluginThreadLocal createGuiceTweaker() {

        SpincastPluginThreadLocal guiceTweaker = super.createGuiceTweaker();

        guiceTweaker.module(new SpincastGuiceModuleBase() {

            @Override
            protected void configure() {
                bind(AppController.class).to(AppControllerTesting.class).in(Scopes.SINGLETON);
            }
        });

        return guiceTweaker;
    }

    @Test
    public void isGzipped() throws Exception {
        // TODO...
    }
}</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">2</span> : this test class also extends 
                        <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/IntegrationTestAppDefaultContextsBase.html">IntegrationTestAppDefaultContextsBase</a>.
                    </li>
                    <li>
                        <span class="code-line-nbr">4-7</span> : we start our application.
                    </li>
                    <li>
                        <span class="code-line-nbr">9-15</span> : we create a <em>mock</em> controller by extending
                        the original one and replacing the <code>sumRoute(...)</code> <code>Route Handler</code>
                        so it always returns "42".
                    </li>
                    <li>
                        <span class="code-line-nbr">17-31</span> : we override the <code>createGuiceTweaker()</code>
                        method to add a custom Guice module to the <a href="#testing_guice_tweaker">Guice Tweaker </a>. As we will see in the next section, 
                        the Guice Tweaker allows us to modify the Guice context of our application, without touching its code directly. 
                        Here, we change the <code>AppController</code> binding so it uses
                        our mock controller implementation instead of the default one.
                    </li>
                </ul>
            </p>  
        </div>  
    </p>
    <p>
        And let's write the test itself :
        
        <div>
            <p>
                <pre class="ace ace-java"
>@Test
public void isGzipped() throws Exception {
 
    HttpResponse response = POST("/sum").addEntityFormDataValue("toto", "titi")
                                        .addJsonAcceptHeader()
                                        .send();

    assertTrue(response.isGzipped());

    assertEquals(HttpStatus.SC_OK, response.getStatus());
    assertEquals(ContentTypeDefaults.TEXT.getMainVariationWithUtf8Charset(),
                 response.getContentType());
    assertEquals("42", response.getContentAsString());
        
}</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">4-6</span> : We can send pretty much anything here as the
                        parameters since the controller is mocked : they won't be validated.
                    </li>
                    <li>
                        <span class="code-line-nbr">8</span> : We validate that the response was gzipped.
                    </li>
                    <li>
                        <span class="code-line-nbr">10-13</span> : just to make sure our tweaking
                        is working properly.
                    </li>
                    
                </ul>
            </p>  
        </div>  
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Being able to change bindings like this is very powerful : you are testing your real application,
        as it is bootstrapped, without even changing its code. All is done <em>indirectly</em>, using 
        the Guice Tweaker.
    </p>
    
</section>

{#==========================================
Guice Tweaker
==========================================#}     
<section id="testing_guice_tweaker">
    <h4>
        <a class="anchor_small" href="#testing_guice_tweaker" title="permanent link"></a>
        Guice Tweaker
    </h4>
    
    <p>
        As we saw in the previous demo, we can tweak the Guice context of our application
        in order to test it. This is done by configuring the 
        <a class="javadoc" href="/public/javadoc/org/spincast/core/guice/GuiceTweaker.html">GuiceTweaker</a>.
    </p>
    <p>
        The Guice Tweaker is in fact a <a href="#plugins">plugin</a>. This plugin is special because
        it is applied even if it's not registered during the bootstrapping of the application.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/tipy.png" /> 
        It's important to know that the Guice Tweaker only works if you are using the
        standard <a href="#boot_bootstrapper">Bootstrapper</a>. It is implemented
        using a <code>ThreadLocal</code> that the bootstrapper will look for.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        The Guice Tweaker is created in the <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/SpincastTestBase.html">SpincastTestBase</a>
        class. By extending this class or one of <a href="#testing_base_classes">its children</a>, you have access to it.
        To configure it, you override the <code>createGuiceTweaker()</code> method and
        modify it as you need. You can see an example of this in the previous demo. 
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        By default, the Guice Tweaker automatically modifies the <code>SpincastConfig</code>
        binding of the application. This allows you to use testing configurations very easily
        (for example to make sure the server starts on a free port). The implementation class used
        for those configurations can be changed by overriding the <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/SpincastTestBase.html#getSpincastConfigTestingImplementation--">getSpincastConfigTestingImplementation()</a>
        method. The Guice tweaker will use this implementation for the binding. The default implementation is <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/utils/SpincastConfigTestingDefault.html">SpincastConfigTestingDefault</a>.
        You can disable that automatic configurations tweaking by overriding the <code>isEnableGuiceTweakerTestingConfigMecanism()</code> method
        and making it return <code>false</code>.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        For integration testing, when a test class extends 
        <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/IntegrationTestBase.html">IntegrationTestBase</a> or one of its
        children, the <a href="/plugins/spincast-http-client-with-websocket">Spincast HTTP Client with WebSockets</a> plugin is also 
        registered automatically by the Guice Tweaker. The features provided by this plugin are used intensively to perform requests.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Finally, the Guice Tweaker provides three main methods to help tweak the Guice context
        of your application&nbsp;:
        
        <ul>
            <li>
                <strong><em>plugin(...)</em></strong> : to apply an extra plugin.
            </li>
            <li>
                <strong><em>pluginToIgnore(...)</em></strong> : to ignore a plugin which would be applied otherwise.
            </li>
            <li>
                <strong><em>module(...)</em></strong> : to install an extra Guice module.
            </li>
        </ul>
    </p>
    
</section>

{#==========================================
Testing base classes
==========================================#}     
<section id="testing_base_classes">
    <h4>
        <a class="anchor_small" href="#testing_base_classes" title="permanent link"></a>
        Testing base classes
    </h4>
    
    <p>
        Multiple base classes are provided, depending on the needs of your test class. They all ultimately extend
        <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/SpincastTestBase.html">SpincastTestBase</a>,
        they all use the <a href="#testing_runner">Spincast JUnit runner</a> and
        all give access to <a href="#testing_guice_tweaker">Guice Tweaker</a>.
    </p>
    <p>
        Those test base classes are split into two main categories : those made for <em>integration testing</em> and those made
        for <em>unit testing</em>. We use the expression <em>"integration testing"</em> when the HTTP Server is started to run the
        tests and <em>"unit testing"</em> otherwise.
    </p>
    <p>
        <strong>Integration testing base classes :</strong>
        <br />
        <ul>
            <li>
                <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/IntegrationTestAppBase.html">IntegrationTestAppBase</a> : base class
                to use to test an application that you are going to start using its <code>main(...)</code> method. 
                This class needs to be parameterized with the <code>Request Context</code> and <code>WebSocket Context</code> types
                to use.
            </li>
            <li>
                <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/IntegrationTestAppDefaultContextsBase.html">IntegrationTestAppDefaultContextsBase</a> : base class
                similar to the previous one, but to use if your application uses the default <code>Request Context</code> and <code>WebSocket Context</code> types. There is
                no need to parameterize this class.
            </li>
            <li>
                <a class="javadoc" href="/public/javadoc/org/spincast/testing/core/IntegrationTestNoAppBase.html">IntegrationTestNoAppBase</a> : base class
                to use when you are not starting an application using its <code>main(...)</code> method. In that case, the base class
                <em>will start the HTTP Server by itself</em>. Also, all routes are going to be cleared before each test.
                This class needs to be parameterized with the <code>Request Context</code> and <code>WebSocket Context</code> types
                to use.
            </li>
            <li>
                <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/IntegrationTestNoAppDefaultContextsBase.html">IntegrationTestNoAppDefaultContextsBase</a> : base class
                similar to the previous one, but if your application uses the default <code>Request Context</code> and <code>WebSocket Context</code> types. There is
                no need to parameterize this class.
            </li>
            <li>
                <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/WebsocketIntegrationTestNoAppBase.html">WebsocketIntegrationTestNoAppBase</a> : base class
                made for test classes involving WebSocket requests. This class needs to be parameterized with the <code>Request Context</code> and <code>WebSocket Context</code> types
                to use.
            </li>
            <li>
                <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/WebsocketIntegrationTestNoAppDefaultContextsBase.html">WebsocketIntegrationTestNoAppDefaultContextsBase</a> : base class
                similar to the previous one, but to use if your application uses the default <code>Request Context</code> and <code>WebSocket Context</code> types. There is
                no need to parameterize this class.
            </li>
        </ul>
    </p>
    <p>
        <strong>Unit testing base classes :</strong>
        <br />
        <ul>
            <li>
                <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/UnitTestBase.html">UnitTestBase</a> : base class
                to use when the HTTP server doesn't need to be started. A default Guice context is still created and you can easily 
                tweak it (for example by using the <code>getExtraOverridingModule()</code> method). Using this class requires you to
                specify the <code>Request Context</code> and <code>WebSocket Context</code> types to use.
            </li>
            <li>
                <a class="javadoc" href="/public/javadoc/org/spincast/defaults/testing/UnitTestDefaultContextsBase.html">UnitTestDefaultContextsBase</a> : base class
                similar to the previous one, but if your components use the default <code>Request Context</code> and <code>WebSocket Context</code> types.
            </li>
        </ul>
    </p>

</section>


{#==========================================
Spincast JUnit runner
==========================================#}         
<section id="testing_runner">
    <h4>
        <a class="anchor_small" href="#testing_runner" title="permanent link"></a>
        Spincast JUnit runner
    </h4>
    
    <p>
        Spincast's testing base classes all use a custom JUnit runner: 
        <a class="javadoc" href="/public/javadoc/org/spincast/testing/utils/SpincastJUnitRunner.html">SpincastJUnitRunner</a>.
    </p>
    <p>
        This custom runner has a couple of differences as compared with the default JUnit runner, 
        but the most important one is that instead of creating a new instance of the test class 
        before each test, this runner only creates <em>one</em> instance. 
    </p>
    <p>
        This way of running the tests works very well when a Guice context is involved.
        The Guice context is created when the test class is initialized, and then this context is used to run all the tests
        of the class. If Integration testing is used, then the HTTP Server 
        is started when the test class is initialized and it is used to run
        all the tests of the class.
    </p>
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Let's see in more details how the Spincast JUnit runner works :
    </p>
    <p>
        <ul>
            <li>
                First, a <code>beforeClass()</code> method is called. As opposed to a classic 
                JUnit's <code>@BeforeClass</code> annotated method, Spincast's <code>beforeClass()</code> method is
                <em>not static</em>. It is called when the test class is initialized.
            </li>
            <li>
                The <code>createInjector()</code> method is called in the <code>beforeClass()</code> method. This is where
                the Guice context will be created, by starting an application or explictly.
            </li>
            <li>
                The dependencies are automatically injected from the Guice context into the instance of the test class. 
                All your <code>@Inject</code> annotated fields and methods are fulfilled.
            </li>
            <li>
                If an exception occurs in the <code>beforeClass()</code> method, the process stops and the
                tests are not run.
            </li>
            <li>
                The tests are then run. Note that since the <code>@FixMethodOrder(MethodSorters.NAME_ASCENDING)</code> annotation is used
                on the <code>SpincastTestBase</code> parent class, the
                tests will be sorted alphanumerically before they are run. Without this annotation,
                JUnit doesn't guarantee the order in which your tests are run.
            </li>
            <li>
                The <code>afterClass()</code> method is called. Like the <code>beforeClass()</code> method, this
                method is not static. Note that the <code>afterClass()</code> method won't be called if an exception occurred
                in the <code>beforeClass()</code> method.
            </li> 
        </ul>
    </p>
    <p>
        Since the Guice context is shared by all the tests of a test class, you have to make sure you reset everything 
        required before running a test. To do this, use JUnit's 
        <a href="https://github.com/junit-team/junit4/wiki/Test-fixtures">@Before</a> annotation, or 
        the <code>beforeTest()</code> and <code>afterTest()</code> method.
    </p>
    
    <h5>
        <a class="anchor_small" href="#testing_runner_features" id="testing_runner_features" title="permanent link"></a>
        Spincast JUnit runner features
    </h5>

    <p>
        <ul>
            <li>
                If your test class is annotated with
                <a class="javadoc" href="/public/javadoc/org/spincast/testing/utils/ExpectingBeforeClassException.html">@ExpectingBeforeClassException</a>
                then the <code>beforeClass()</code> method is expected to throw an exception! In other words, the test class will be
                shown by JUnit as a "success" only of the <code>beforeClass()</code> method throws an exception. This is useful,
                in integration testing, to validate that your application refuses some invalid configuration when 
                it starts, for example.
            </li>
            <li>
                If your test class (or a parent) implements
                <a class="javadoc" href="/public/javadoc/org/spincast/testing/utils/TestFailureListener.html">TestFailureListener</a>
                then the <code>testFailure(...)</code> method will be called each time a test fails. This
                allows you to add a breakpoint or some logs, and to inspect the context of the failure.
            </li>
            <li>
                You can use the <a class="javadoc" href="/public/javadoc/org/spincast/testing/utils/Repeat.html">@Repeat</a> annotation. 
                When added to the class itself, this annotation makes your test class loop X number of times. Note that the 
                <code>beforeClass()</code> and <code>afterClass()</code> methods will also be called X number of time, so the
                Guice context will be recreated each time.
                You can specify an amount of milliseconds to sleep between two loops, using the <code>sleep</code> parameter.
            </li>
            <li>
                You can also use the <a class="javadoc" href="/public/javadoc/org/spincast/testing/utils/Repeat.html">@Repeat</a> annotation
                <em>on a test</em>. This will make the test run X number of time during the execution of a test class
                loop.
            </li>
            <li>
                If your test class (or a parent) implements
                <a class="javadoc" href="/public/javadoc/org/spincast/testing/utils/RepeatedClassAfterMethodProvider.html">RepeatedClassAfterMethodProvider</a> 
                then the <code>afterClassLoops()</code> method will be called when all the loops of the test class have been
                run.
            </li>
        </ul>
    </p>
    <p>
        A quick note about the <code>@Repeat</code></a> annotation : this annotation should probably only be used 
        for <em>debugging</em> purpose! A test should always be reproducible and should probably not have
        to be run multiple times. But this annotation, in association with the 
        <code>testFailure(...)</code> method, can be a great help to debug a test
        which <em>sometimes</em> fails and you don't know why!
    </p>
    
</section>

    
    
    
    