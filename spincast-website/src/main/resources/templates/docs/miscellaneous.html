{#==========================================
Docs : "Miscellaneous"
==========================================#}

<section id="miscellaneous">
    <h3>
        <a class="anchor" href="#miscellaneous" title="permanent link"></a>
        Miscellaneous
    </h3>
</section>
   
{#==========================================
Default Configurations
==========================================#}     
<section id="default_config">
    <h4>
        <a class="anchor_small" href="#default_config" title="permanent link"></a>
        Default Configurations
    </h4>
    
    <p>
        To know what are the default Spincast configurations,
        have a look at the
        <a href="/plugins/spincast-config#spincast_config">Spincast Config plugin</a> page, which is the
        default implementation of the "<code>ISpincastConfig</code>" interface. But here are some
        important ones:
    </p>
    <p>
        <ul>
            <li>
                <code>getServerHost()</code> : The host/IP the HTTP server
                will listen on. The default is <code>0.0.0.0</code>, which
                means the server will listen on any IP.
            </li>
            <li>
                <code>getHttpServerPort()</code> : The port the server
                will listen to for <code>HTTP</code> <em>(unsecure)</em> requests.
                If <code>&lt;= 0</code>, the server won't listen on <code>HTTP</code> requests.
            </li>
            <li>
                <code>getHttpsServerPort()</code> : The port the server
                will listen to for <code>HTTPS</code> <em>(secure)</em> requests.
                If <code>&lt;= 0</code>, the server won't listen on <code>HTTPS</code> requests.
                If you use <code>HTTPS</code>, you also have to provide some extra
                configurations related to the <code class="block">SSL</code>
                certificate to use.
            </li>
            <li>
                <code>isDebugEnabled()</code> : If <code>true</code>,
                a <em>development</em> environment is taken for granted, and
                internal error messages may be displayed publicly, no cache will be
                used for the templates, etc. The default is <code>true</code>, so make
                sure you change this to <code>false</code> before deploying to
                production!
            </li>

        </ul>
    </p>
</section>

{#==========================================
Templating engine
==========================================#}     
<section id="templating_engine">
    <h4>
        <a class="anchor_small" href="#templating_engine" title="permanent link"></a>
        Templating engine (view engine)
    </h4>
    
    <p>
        The templating engine (also called <em>view engine</em>, or <em>template engine</em>), is the component you use
        to generate dynamic <code>HTML</code> pages. It can be used for other purposes, for example to generate
        the body of an email when some placeholders have to be replaced in the base template, but its
        most frequent use is to generate <code>HTML</code> pages.
    </p>
    <p>
        You can inject the <a href="/plugins/spincast-pebble#templatingengine"><code>ITemplatingEngine</code></a> component 
        anywhere you need it, but to generate <code>HTML</code> pages the preferred way is to use the
        methods provided by the <code><em>response()</em></code> <code>add-on</code>, on
        the <code>request context</code> objects:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java"
>public class AppController {

    public void myRouteHandler(IAppRequestContext context) {

        IUser user = getUser();

        Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();
        params.put("user", user);

        // A template which is on the classpath:
        context.response().sendHtmlTemplate("/templates/user.html",
                                            params);

        // Or, a template which is on the file system:
        context.response().sendHtmlTemplate("/usr/www/myProject/templates/user.html",
                                            false,
                                            SpincastStatics.params("user", user));
    }
}</pre> 
            </p>
                <p>
                    <span class="explanation">Explanation :</span>
                    <ul>
                        <li>
                            <span class="code-line-nbr">11</span> : We use the <code>response()</code>
                            add-on to access the <code>sendHtmlTemplate(...)</code> method. This method
                            takes two parameters: the path to the <code>HTML</code> template to use (listed below)
                            and a set of variables to use to generate the final output. By default, the 
                            <code>templating engine</code> will try to find the template file <em>on the classpath</em>.
                        </li>
                        <li>
                            <span class="code-line-nbr">12</span> : We pass a <code>user</code>
                            object to the <code>templating engine</code> so it can use it to
                            generate the final <code>HTML</code>. Here, we do so using a classic 
                            <code>Map&ltString, Object&gt;</code> structure (<span class="code-line-nbr">7-8</span>).
                        </li>
                        <li>
                            <span class="code-line-nbr">15-16</span> : By passing <code>false</code> as
                            a second parameter to the <code>sendHtmlTemplate(...)</code> method, we can also tell
                            the <code>templating engine</code> to search for the template
                            <em>on the file system</em>, and not on the classpath.
                        </li>
                        <li>
                            <span class="code-line-nbr">17</span> : <code>SpincastStatics.params(...)</code>
                            is a utility method provided by Spincast to easily create 
                            <code>Map&ltString, Object&gt;</code> parameters, <em>inline</em>. It is equivalent to
                            creating a <code>new HashMap&lt;String, Object&gt;()</code> as in the first example (<span class="code-line-nbr">7-8</span>).
                        </li>
                        
                    </ul>
                </p>  
        </div>
    </p>  
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Here's an example template file which would be on the classpath 
        (for example, at <code>src/resources/templates/user.html</code>, in the
        project). Note that the syntax used inside your templates depends on the 
        implementation of the <code>templating engine</code> 
        you use! In this example, we use the default implementation, 
        <a href="/plugins/spincast-pebble">Pebble</a>:
    </p>
    <p>
        <div>
            <p>
                {% verbatim %}
                <pre class="ace ace-html" data-ace-hi="7,18,7,31"
>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;title&gt;Test&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Hello {{user.name}}!&lt;/h1&gt; 
    &lt;/body&gt;
&lt;/html&gt;</pre> 
             {% endverbatim %}
            </p> 
        </div>
    </p>  
    <p>
        <img class="inlineIcon" src="/public/images/icons/para.png" /> 
        Finally, note that you can also access the <code>templating engine</code> via its own <code><em>"templating()"</em></code>
        <code>add-on</code>, on the <code>request context</code> objects. 
        This can be useful when you need to generate some dynamic content
        without sending it as the <code>response</code> for the current request:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java" data-ace-hi="6,34,6,47"
>public class AppController {

    public void myRouteHandler(IAppRequestContext context) {

        IUser user = getUser();
        
        String emailBody = context.templating().fromTemplate("/templates/email.html", 
                                                             SpincastStatics.params("user", user));
        // Do something with the 'emailBody'...
    }
}</pre> 
            </p> 
        </div>
    </p>  
   
</section>
   
{#==========================================
SSL
==========================================#}     
<section id="ssl">
    <h4>
        <a class="anchor_small" href="#ssl" title="permanent link"></a>
        Using a SSL certificate (HTTPS)
    </h4>
    
    <p>
        It is recommended that you serve your application over <code>HTTPS</code> and
        not <code>HTTP</code>, which is not secure. To achieve that, you need to install a 
        <code>SSL certificate</code>.
    </p>
    <p>
        If you download the <a href="#quick_start">Quick Start</a> application, you will
        find two files explaining the required procedure:
        
        <ul>
            <li>
                <code>/varia/ssl_certificate_howto/self-signed.txt</code>
                <br />
                Shows how to use a <code>self-signed</code> certificate, for development
                purpose.
            </li>
            <li>
                <code>/varia/ssl_certificate_howto/lets-encrypt.txt</code>
                <br />
                Shows how to use a <a href="https://letsencrypt.org/"><code>Let's Encrypt</code></a> 
                certificate. <code>Let's Encrypt</code> is a provider of <em>free</em>, but totally valid,
                <code>SSL certificates</code>. Instructions in this file will probably work for certificates 
                obtained from other providers, but we haven't tested it yet.
            </li> 
        </ul>
    </p>
</section>

{#==========================================
JsonObject
==========================================#}     
<section id="jsonobject">
    <h4>
        <a class="anchor_small" href="#jsonobject" title="permanent link"></a>
        JsonObject
    </h4>
    
    <p>
        The <code>JsonObject</code> (interface <code>IJsonObject</code>) is a class
        provided by Spincast to mimic a real <code>Json</code> object. It is, essentially,
        a <em>typed</em> <code>Map&ltString, Object&gt;</code>. So there is a <code>put(String key, Object value)</code>
        method, but the getters are typed: 
        
        <ul>
            <li>
                <code>String getString(String key)</code>
            </li>
            <li>
                <code>Integer getInteger(String key)</code>
            </li> 
            <li>
                <code>IJsonObject getJsonObject(String key)</code>
            </li> 
            <li>
                ...
            </li> 
        </ul>  
    </p>
    <p>
        You can create a <code>JsonObject</code>, or a <code>JsonArray</code>, using the <code>IJsonManager</code>
        component. This component can be injected by Guice, or it can be accessed through the
        <code>json()</code> add-on:
        <div>
            <p>
                <pre class="ace ace-java"
>public void myHandler(IAppRequestContext context) {

    IJsonObject obj = context.json().create();
    obj.put("name", "Stromgol");
    obj.put("lastName", "Laroche");

    context.response().sendJsonObj(obj);
}</pre> 
            </p>
        </div>
    </p>   
    
    <p>
        Spincast uses <code>JsonObject</code> objects in many places. For example,
        to get the content of a request for which a <code>Json</code> body has been sent
        via <code>ajax</code> :
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java"
>public void myHandler(IAppRequestContext context) {
    IJsonObject json = context.request().getJsonBodyAsJsonObject();
    // ...
}}</pre> 
            </p>
        </div>
    </p>   
    <p>
        Or even when <code>XML</code> is sent :
        <div>
            <p>
                <pre class="ace ace-java"
>public void myHandler(IAppRequestContext context) {
    IJsonObject json = context.request().getXmlBodyAsJsonObject();
    // ...
}}</pre> 
            </p>
        </div>
    </p>   

</section>

{#==========================================
Spincast Utilities
==========================================#}     
<section id="spincast_utils">
    <h4>
        <a class="anchor_small" href="#spincast_utils" title="permanent link"></a>
        Spincast Utilities
    </h4>
    
    <p>
        Spincast provides some generic utilities, accessible via the <code>ISpincastUtils</code>
        interface:
    </p>
    <p>
        <ul class="apiList">

<li>
    <code class="apiItem">void <span>zipDirectory</span>(File directoryToZip, File targetZipFile, boolean includeDirItself)</code>
    <div class="well">
         Zips a directory.

        <div class="apiItemFooter">
            @param targetZipFile the target .zip file. If the parent directories don't
 exist, tries to create them.
<br />@param If <code>true</code>, the directory itself will be included in the
 zip file, otherwise only its content will be.

        </div>
    </div>
</li>

<li>
    <code class="apiItem">void <span>zipExtract</span>(File zipFile, File targetDir)</code>
    <div class="well">
         Extracts a .zip file to the specified directory.

        <div class="apiItemFooter">
            @param targetDir The target directory. If it doesn't exist, tried to
 create it (and its parents, if required).

        </div>
    </div>
</li>

<li>
    <code class="apiItem">String <span>getMimeTypeFromMultipleSources</span>(String responseContentTypeHeader,                                                  String resourcePath,                                                  String requestPath)</code>
    <div class="well">
         Gets the <code>mime type</code> using multiple sources of information.

        <div class="apiItemFooter">
            @param contentTypeHeader an already existing Content-Type header on the
 response. Can be null.
<br />@param resourcePath the path (absolute or relative) to the target resource. Can be null.
<br />@param requestPath the path of the current request. Can be null.
<br />@return the <code>mime type</code> or <code>null</code> if it can't be
 decided.

        </div>
    </div>
</li>

<li>
    <code class="apiItem">String <span>getMimeTypeFromPath</span>(String path)</code>
    <div class="well">
         Gets the <code>mime type</code> from a path, using its extension.

        <div class="apiItemFooter">
            @return the <code>mime type</code> or <code>null</code> if it can't be
 decided.

        </div>
    </div>
</li>

<li>
    <code class="apiItem">String <span>getMimeTypeFromExtension</span>(String extension)</code>
    <div class="well">
         Gets the <code>mime type</code> from the extension.

        <div class="apiItemFooter">
            @return the <code>mime type</code> or <code>null</code> if it can't be
 decided.

        </div>
    </div>
</li>

<li>
    <code class="apiItem">Locale <span>getLocaleBestMatchFromAcceptLanguageHeader</span>(String acceptLanguageHeader)</code>
    <div class="well">
         Gets the best Locale to use given a "Accept-Language" HTTP header.

        <div class="apiItemFooter">
            @return the best Locale to use or <code>null</code>
 if the given header can't be parsed.

        </div>
    </div>
</li>

<li>
    <code class="apiItem">boolean <span>isContentTypeToSkipGziping</span>(String contentType)</code>
    <div class="well">
         Should the specified <code>Content-Type</code> be gzipped?

    </div>
</li>

<li>
    <code class="apiItem">File <span>getAppJarDirectory</span>()</code>
    <div class="well">
         Returns the working directory: the directory
 in which the executable .jar is located.

        <div class="apiItemFooter">
            @return the working directory or <code>null</code> if the application is
 running inside an IDE.

        </div>
    </div>
</li>

<li>
    <code class="apiItem">String <span>getSpincastCurrentVersion</span>()</code>
    <div class="well">
         Gets the current Spincast version.

    </div>
</li>

<li>
    <code class="apiItem">String <span>getCacheBusterCode</span>()</code>
    <div class="well">
         The cache buster to use.
 <p>
 This should probably change each time
 the application is restarted or at least redeployed.
 </p>
 <p>
 It should also be in such a format that it's possible to
 remove it from a given text.
 </p>
 <p>
 This must be kept in sync with
 <code>removeCacheBusterCode</code>!
 </p>

    </div>
</li>

<li>
    <code class="apiItem">String <span>removeCacheBusterCodes</span>(String text)</code>
    <div class="well">
         Removes the cache buster code occurences from the
 given text.
 <p>
 Note that this won't simply remove the <em>current</em>
 cache busting code, it will remove <em>any</em> valid cache busting code...
 This is what we want since we don't want a client sending a request
 containing an old cache busting code to break!
 </p>
 <p>
 This must be kept in sync with
 <code>getCacheBusterCode</code>!
 </p>

    </div>
</li>




            
            
        </ul>
    </p> 

</section>


{#==========================================
@MainArgs
==========================================#}     
<section id="main_args">
    <h4>
        <a class="anchor_small" href="#main_args" title="permanent link"></a>
        @MainArgs
    </h4>
    
    <p>
        Both <code>SpincastCoreGuiceModule</code> and <code>SpincastDefaultGuiceModule</code>
        Guice modules have a constructor which accepts
        <code>String[] mainArgs</code>. You can pass to it the arguments received in
        your <code>main(...)</code> method. For example:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java" data-ace-hi="0,24,0,37|2,73,2,77"
>public static void main(String[] args) {

    Injector guice = Guice.createInjector(new SpincastDefaultGuiceModule(args));

    App app = guice.getInstance(App.class);
    app.start();
}</pre> 
            </p>
        </div>
    </p>   
    <p>
        By doing so, those arguments will be bound, using a <code>@MainArgs</code>
        annotation. You can then inject them anywhere you need:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java" data-ace-hi="5,21,5,48"
>public class AppConfig extends SpincastConfig implements IAppConfig {

    private final String[] mainArgs;

    @Inject
    public AppConfig(@MainArgs String[] mainArgs) {
        this.mainArgs = mainArgs;
    }

    protected String[] getMainArgs() {
        return this.mainArgs;
    }

    @Override
    public int getHttpServerPort() {

        int port = super.getHttpServerPort();
        if(getMainArgs().length &gt; 0) {
            port = Integer.parseInt(getMainArgs()[0]);
        }
        return port;
    }
}</pre> 
            </p>
        </div>
    </p>   
    
</section>

{#==========================================
Using an init() method
==========================================#}     
<section id="init_method">
    <h4>
        <a class="anchor_small" href="#init_method" title="permanent link"></a>
        Using an <code>init()</code> method
    </h4>
    
    <p>
        This is more about standard Guice development than about Spincast, but we
        feel it's a useful thing to know.
    </p>
    <p>
        Guice doesn't provide
        support for a <code>@PostConstruct</code> annotation out of the box.
        And since it is often seen as a bad practice to do too much work directly in a constructor, what we want
        is an <code>init()</code> method to be called <em>once the
        object it fully constructed</em>, and do the initialization work there. 
    </p>
    <p>
        The trick is that Guice calls any <code>@Inject</code> annotated methods
        once the object is created, so let's use this to our advantage:
    </p>
    <p>
        <div>
            <p>
                <pre class="ace ace-java"
>public class UserService implements IUserService {

    private final ISpincastConfig spincastConfig;

    @Inject
    public UserService(ISpincastConfig spincastConfig) {
        this.spincastConfig = spincastConfig;
    }

    @Inject
    protected void init() {
        doSomeValidation();
        doSomeInitialization();
    }

    //...
}</pre> 
            </p>
            <p>
                <span class="explanation">Explanation :</span>
                <ul>
                    <li>
                        <span class="code-line-nbr">5-8</span> : The constructor's job is only to
                        receive the dependencies.
                    </li>
                    <li>
                        <span class="code-line-nbr">10-14</span> : An <code>init()</code> method is
                        also annotated with <code>@Inject</code>. This method will be called once the
                        object is fully constructed. This is a good place to do some initialization work!
                    </li>
                </ul>
            </p> 
        </div>
    </p>   
    <p>
        What we recommend is <em>constructor injection</em> + one (and only one) <code>@Inject</code> 
        annotated method. The problem with multiple <code>@Inject</code> annotated methods (other than 
        constructors) is that it's hard to know in which order they will be called.
    </p>   
    <p>
        Finally, if the <code>init()</code> method must be called <em>as soon as the application starts</em>, make sure
        you bind the object using
        <a href="https://github.com/google/guice/wiki/Scopes#eager-singletons">asEagerSingleton()</a>!
    </p>
    
</section>        
            
            